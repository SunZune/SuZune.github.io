
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>hellWorld - SunZune的博客</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="SunZune,"> 
    <meta name="description" content="\面试题**\第一天**\1、简单说说线程的几种状态 以及线程的阻塞的方式**早期的进程状态，也就是单线程进程的状态。有五种
\（1）新建状态**：即单纯地创建一个线程，创建线程有三种方式
​   ,"> 
    <meta name="author" content="John Doe"> 
    <link rel="alternative" href="atom.xml" title="SunZune的博客" type="application/atom+xml"> 
    <link rel="icon" href="/img/ico/14.ico"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 4.2.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">SunZune的博客</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="icon-home image-icon" href="javascript:;" data-url="http://sunzune.github.io"></a>
    <div title="播放/暂停" class="icon-play"></div>
    <h3 class="subtitle">hellWorld</h3>
    <div class="social">
        <!--<div class="like-icon">-->
            <!--<a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
        <!--</div>-->
        <div>
            <div class="share">
                <a title="获取二维码" class="icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">hellWorld</h1>
        <div class="stuff">
            <span>十二月 27, 2019</span>
            

        </div>
        <div class="content markdown">
            <h1 id="面试题"><a href="#面试题" class="headerlink" title="\面试题**"></a><strong><em>\</em>面试题**</strong></h1><h2 id="第一天"><a href="#第一天" class="headerlink" title="\第一天**"></a><strong><em>\</em>第一天**</strong></h2><h4 id="1、简单说说线程的几种状态-以及线程的阻塞的方式"><a href="#1、简单说说线程的几种状态-以及线程的阻塞的方式" class="headerlink" title="\1、简单说说线程的几种状态 以及线程的阻塞的方式**"></a><strong><em>\</em>1、简单说说线程的几种状态 以及线程的阻塞的方式**</strong></h4><p>早期的进程状态，也就是单线程进程的状态。有五种</p>
<p><strong><em>\</em>（1）新建状态**</strong>：即单纯地创建一个线程，创建线程有三种方式</p>
<p>​    继承Thread类创建线程</p>
<p>​    实现Runnable接口创建线程</p>
<p>​    实现Callable接口创建线程</p>
<p><strong><em>\</em>（2）就绪状态：**</strong>在创建了线程之后，调用Thread类的start()方法来启动一个线程，即表示线程进入就绪状态！</p>
<p><strong><em>\</em>（3）运行状态**</strong>：当线程获得CPU时间片后，线程才从就绪状态进入到运行状态！</p>
<p><strong><em>\</em>（4）阻塞状态：**</strong>阻塞又分为等待阻塞、同步阻塞、其它阻塞。线程进入运行状态后，可能由于多种原因让线程进入阻塞状态，如：调用sleep()方法让线程睡眠，调用wait()方法让线程等待，调用join()方法、suspend()方法（它现已被弃用！）以及阻塞式IO方法。</p>
<p><strong><em>\</em>（5）死亡状态**</strong>：run()方法的正常退出就让线程进入到死亡状态，还有当一个异常未被捕获而终止了run()方法的执行也将进入到死亡状态！</p>
<p>JDK源码中</p>
<p>Java线程有六个状态：</p>
<p>\1. New:初始状态，线程被创建，没有调用start（）</p>
<p>\2. Runnable:运行状态，Java线程把操作系统中的就绪和运行两种状态统一称为“运行中”，一个表示的start了，资源一到位随时可以执行，另一个表示真正的执行中</p>
<p>\3. Blocked:阻塞|锁池，线程等待获取一个锁，来继续执行下一步的操作。，在未获取之前，其线程的状态就一直未Blocked。线程进入等待状态，线程因为某种原因，放弃了CPU的使用权</p>
<p>阻塞的几种情况：</p>
<p>A. 等待阻塞：运行的线程执行了wait()，JVM会把当前线程放入等待队列</p>
<p>B. 同步阻塞：运行的线程在获取对象的同步锁时，如果该同步锁被其他线程占用了，JVM会把当前线程放入锁池中</p>
<p>C. 其他阻塞：运行的线程执行sleep(),join()或者发出IO请求时，JVM会把当前线程设置为阻塞状态，当sleep()执行完，join()线程终止，IO处理完毕线程再次恢复</p>
<p>\4. Waiting:等待状态</p>
<p>\5. timed_waiting:超时等待状态，超时以后自动返回。这个状态和Waiting状态的区别就是，这个状态的等待是有一定时效的，即可以理解为Waiting状态等待的时间是永久的，即必须等到某个条件符合才能继续往下走，否则线程不会被唤醒。但是timed_waiting等待一段时间之后，会唤醒线程去重新获取锁</p>
<p>\6. terminated:终止状态，当前线程执行完毕</p>
<p><strong><em>\</em>Java中实现线程阻塞的方法：**</strong></p>
<p>（1）线程睡眠：Thread.sleep (long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。</p>
<p>（2）线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait() 一样。wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用.</p>
<p>（3）线程礼让，Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.</p>
<p>（4）线程自闭，join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。</p>
<p>（5）suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。</p>
<h4 id="2、简单说说hashmap的底层实现原理"><a href="#2、简单说说hashmap的底层实现原理" class="headerlink" title="\2、简单说说hashmap的底层实现原理**"></a><strong><em>\</em>2、简单说说hashmap的底层实现原理**</strong></h4><h4 id="3、一万个人抢100个红包，如何实现（不用队列），如何保证2个人不能抢到同一个红包，可用分布式锁"><a href="#3、一万个人抢100个红包，如何实现（不用队列），如何保证2个人不能抢到同一个红包，可用分布式锁" class="headerlink" title="\3、一万个人抢100个红包，如何实现（不用队列），如何保证2个人不能抢到同一个红包，可用分布式锁**"></a><strong><em>\</em>3、一万个人抢100个红包，如何实现（不用队列），如何保证2个人不能抢到同一个红包，可用分布式锁**</strong></h4><p>可用jedisLock—redis分布式锁实现：基本原理：用一个状态值表示锁，对锁的占用和释放通过状态值来标识。</p>
<h4 id="4、两个Integer的引用对象传给一个swap方法在方法内部交换引用，返回后，两个引用的值是否会发现变化，原因是什么？"><a href="#4、两个Integer的引用对象传给一个swap方法在方法内部交换引用，返回后，两个引用的值是否会发现变化，原因是什么？" class="headerlink" title="\4、两个Integer的引用对象传给一个swap方法在方法内部交换引用，返回后，两个引用的值是否会发现变化，原因是什么？**"></a><strong><em>\</em>4、两个Integer的引用对象传给一个swap方法在方法内部交换引用，返回后，两个引用的值是否会发现变化，原因是什么？**</strong></h4><p>不会！Java里方法的参数传递方式只有一种：值传递。</p>
<p><img src="file:///C:/Users/23349/AppData/Local/Temp/ksohtml1160/wps1.jpg" alt="img"> </p>
<h4 id="5、-aop的底层实现，动态代理是如何动态，假如有100个对象，如何动态的为这100个对象代理"><a href="#5、-aop的底层实现，动态代理是如何动态，假如有100个对象，如何动态的为这100个对象代理" class="headerlink" title="5、****aop的底层实现，动态代理是如何动态，假如有100个对象，如何动态的为这100个对象代理****"></a><strong>5、***</strong>*aop的底层实现，动态代理是如何动态，假如有100个对象，如何动态的为这100个对象代理****</h4><p>在Spring 中,虽然引入了AspectJ的语法,但是他本质上使用的是动态代理的方式.但即使是动态代理,也分两种实现模式:</p>
<p>.使用接口(动态代理)</p>
<p>如果被代理的对象是面向接口编程的,那么Spring直接使用实现这些接口,然后把需要插入的内容在这个接口上下文中插入</p>
<p>.使用继承(CGLIB)</p>
<p>如果被代理的对象没有基于接口编程,那么Spring会调用cglib库,通过子类继承的方式,动态插入需要的内容,并且调用父类的方法实现</p>
<p>cglib内部拥有一个小的字节码处理框架asm,来转换字节码生成新的类.所以spring调用了cglib,相当于生成了一个被代理对象的子类,来取代被代理对象.</p>
<p><strong><em>\</em>实现原理**</strong><br>Spring框架的AOP技术底层也是采用的代理技术，所谓的动态代理就是说 AOP 框架不会去修改字节码，而是在内存中临时为方法生成一个 AOP 对象，这个 AOP 对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法 。Spring AOP 中的动态代理主要有两种方式， JDK 动态代理和 CGLIB 动态代理 。</p>
<p>JDK 动态代理：通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口 。JDK 动态代理的核心是 InvocationHandler 接口和 Proxy 类 。</p>
<p>CGLIB动态代理：如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类 。CGLIB （ Code Generation Library ），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意， CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final ，那么它是无法使用 CGLIB 做动态代理的。</p>
<p>· </p>
<h4 id="6、spring的bean配置的几种方式？"><a href="#6、spring的bean配置的几种方式？" class="headerlink" title="\6、spring的bean配置的几种方式？**"></a><strong><em>\</em>6、spring的bean配置的几种方式？**</strong></h4><p>基于XML的配置、基于注解的配置和基于Java类的配置。</p>
<h4 id="7、说说spring的监听器的实现原理？"><a href="#7、说说spring的监听器的实现原理？" class="headerlink" title="\7、说说spring的监听器的实现原理？**"></a><strong><em>\</em>7、说说spring的监听器的实现原理？**</strong></h4><h4 id="8、java有哪些锁？乐观锁-悲观锁-synchronized-可重入锁-读写锁-用过reentrantlock吗？reentrantlock与synmchronized的区别"><a href="#8、java有哪些锁？乐观锁-悲观锁-synchronized-可重入锁-读写锁-用过reentrantlock吗？reentrantlock与synmchronized的区别" class="headerlink" title="\8、java有哪些锁？乐观锁 悲观锁 synchronized 可重入锁 读写锁,用过reentrantlock吗？reentrantlock与synmchronized的区别**"></a><strong><em>\</em>8、java有哪些锁？乐观锁 悲观锁 synchronized 可重入锁 读写锁,用过reentrantlock吗？reentrantlock与synmchronized的区别**</strong></h4><p>乐观锁 悲观锁 synchronized 可重入锁 读写锁</p>
<p>ReentrantLock 拥有Synchronized相同的并发性和内存语义，此外还多了 锁投票，定时锁等候和中断锁等候</p>
<p>在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；</p>
<p>synchronized： </p>
<p>在资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized是很合适的。原因在于，编译程序通常会尽可能的进行优化synchronize</p>
<p>ReentrantLock: </p>
<p>ReentrantLock提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等。在资源竞争不激烈的情形下，性能稍微比synchronized差点点。但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍。而ReentrantLock确还能维持常态。 </p>
<h4 id="9、-说说你了解的ThreadLocal的使用场景"><a href="#9、-说说你了解的ThreadLocal的使用场景" class="headerlink" title="9、****说说你了解的ThreadLocal的使用场景****"></a><strong>9、***</strong>*说说你了解的ThreadLocal的使用场景****</h4><p><strong><em>\</em>例如：**</strong></p>
<p><strong><em>\</em>Activity中设置当前用户时，使用的**</strong></p>
<p>Authentication.setAuthenticatedUserId(userName);</p>
<p>Authentication中就定义了一个ThreadLocal的局部变量</p>
<p>ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p>
<p>多个线程之间对ThreadLocal的操作互不影响。</p>
<p>1、方便同一个线程使用某一对象，避免不必要的参数传递；</p>
<p>2、线程间数据隔离（每个线程在自己线程里使用自己的局部变量，各线程间的ThreadLocal对象互不影响）；</p>
<p>3、获取数据库连接、Session、关联ID（比如日志的uniqueID，方便串起多个日志）；</p>
<h4 id="10、为什么线程执行要调用start而不是直接run（直接run，跟普通方法没什么区别，先调start，run才会作为一个线程方法运行）"><a href="#10、为什么线程执行要调用start而不是直接run（直接run，跟普通方法没什么区别，先调start，run才会作为一个线程方法运行）" class="headerlink" title="\10、为什么线程执行要调用start而不是直接run（直接run，跟普通方法没什么区别，先调start，run才会作为一个线程方法运行）**"></a><strong><em>\</em>10、为什么线程执行要调用start而不是直接run（直接run，跟普通方法没什么区别，先调start，run才会作为一个线程方法运行）**</strong></h4><p>run()方法只是一个类中的普通方法，直接执行和普通的方法没有设么两样，直接调用run方法是无法开启一个新线程的</p>
<p>start()方法则不同，start（）方法来启动线程，真正实现了多线程运行。它首先做了创建线程等一系列工作，然后调用行的run()方法</p>
<h2 id="第二天"><a href="#第二天" class="headerlink" title="\第二天**"></a><strong><em>\</em>第二天**</strong></h2><h3 id="1、简单说说memcache和redis的两种缓存的区别以及分别使用什么样的项目中？"><a href="#1、简单说说memcache和redis的两种缓存的区别以及分别使用什么样的项目中？" class="headerlink" title="\1、简单说说memcache和redis的两种缓存的区别以及分别使用什么样的项目中？**"></a><strong><em>\</em>1、简单说说memcache和redis的两种缓存的区别以及分别使用什么样的项目中？**</strong></h3><p> 区别：</p>
<p>1、 Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等。</p>
<p> 2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash，sort，string等数据结构的 存储。</p>
<p>3、虚拟内存—Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘</p>
<p>4、过期策略—memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通 过例如expire 设定，例如expire name 10</p>
<p>5、分布式—设定memcache集群，利用magent做一主多从;redis可以做一主多从。都 可以一主一从</p>
<p>6、存储数据安全—memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）</p>
<p>7、灾难恢复—memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复</p>
<p>8、Redis支持数据的备份，即master-slave模式的数据备份。</p>
<p>redis是单线程实现，若需要使用控制某些并发状态时，可以使用redis.项目中需要使用 复    杂的list,set操作时，同时可以对数据进行持久化。</p>
<p>当存储数据较大时，如100k以上，那memcache性能较好，在多核上，memcache较好</p>
<h3 id="2、-简单讲讲mysql的锁机制以及的行级锁加在哪个位置？"><a href="#2、-简单讲讲mysql的锁机制以及的行级锁加在哪个位置？" class="headerlink" title="2、****简单讲讲mysql的锁机制以及的行级锁加在哪个位置？****"></a><strong>2、***</strong>*简单讲讲mysql的锁机制以及的行级锁加在哪个位置？****</h3><p>不同的存储引擎支持不同的锁机制 ，MyISAM存储引擎采用的是表级锁（table-level     locking）；InnoDB存储引擎既支持行级锁（ row-level locking），也支持表级锁，但默认情况    下是采用行级锁。</p>
<p>行级锁仅对指定的记录进行加锁，这样其它进程还是可以对同一个表中的其它记录进行操    作。</p>
<h3 id="3、-你了解的Mysql的几种引擎？-分别适合什么样的数据库"><a href="#3、-你了解的Mysql的几种引擎？-分别适合什么样的数据库" class="headerlink" title="3、****你了解的Mysql的几种引擎？ 分别适合什么样的数据库****"></a><strong>3、***</strong>*你了解的Mysql的几种引擎？ 分别适合什么样的数据库****</h3><p>四种常用的存储引擎</p>
<p>MyiSAM：速度快。不支持事务、外键。适用于对事务的完整性没有要求，或以select、insert为主的应用。在web、数据仓库中应用广泛</p>
<p>InnoDB：MySQL5.5后的默认引擎。支持事务、外键。相比较于MyISAM，写的处理效率差一点。如果应用对事务的完整性有较高的要求，在并发条件下要求数据的一致性，数据操作中包含读、插入、删除、更新，那InnoDB是最好的选择。在计费系统、财务系统等对数据的准确性要求较高的系统中被广泛应用。</p>
<p>MEMORY：用保存在内存中的数据创建表。数据在内存中，默认使用HASH索引，访问快，但是数据库服务关闭数据就会丢失。内容变化不频繁的代码表，作为统计操作的中间结果表，便于利用它速率快的优势高效的对中间结果进分析。</p>
<p>Merge：是一组MyISAM表的组合，这些myisam表的结构必须完全相同，MERGE表本身并没有数据，对它的操作实际上是对内部MYISAM表的操作。用于将一系列MyISAM表以逻辑方式组合在一起，并作为一个对象引用它们。</p>
<h3 id="4、-mysql的性能优化方式有哪些，你用过哪几种，分别在什么情况下去使用的"><a href="#4、-mysql的性能优化方式有哪些，你用过哪几种，分别在什么情况下去使用的" class="headerlink" title="4、****mysql的性能优化方式有哪些，你用过哪几种，分别在什么情况下去使用的****"></a><strong>4、***</strong>*mysql的性能优化方式有哪些，你用过哪几种，分别在什么情况下去使用的****</h3><p>1、选取最适用的字段属性</p>
<p>2、使用连接（JOIN）来代替子查询(Sub-Queries)</p>
<p>3、使用联合(UNION)来代替手动创建的临时表</p>
<p>4、事务</p>
<p>5、锁定表</p>
<p>6、使用外键</p>
<p>7、使用索引</p>
<p>8、优化的查询语句</p>
<p>尽量把字段设置为NOTNULL，这样在将来执行查询的时候，数据库不用去比较NULL值。字段长度，例如邮编，设置为CHAR(6)，避免浪费数据库空间。对相关类创建索引。避免全表扫描，尽量避免使用！=、&lt;&gt;、Like，最好在相同类型的字段间进行比较，在建立索引的字段上尽量不要使用函数表达式。</p>
<h3 id="5、-谈谈你对Java垃圾回收机制的了解"><a href="#5、-谈谈你对Java垃圾回收机制的了解" class="headerlink" title="5、****谈谈你对Java垃圾回收机制的了解****"></a><strong>5、***</strong>*谈谈你对Java垃圾回收机制的了解****</h3><p>当一个对象的引用不可达，或者一个对象没有任何引用指向它，那么，他就没有必要在内存中继续存在，此时它就是可以被GC回收的对象。这种方法简单粗暴，效率高。</p>
<p>标记—-清除算法：分为标记和清除两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收被标记的对象。这种算法有两个不足的地方，一个是效率问题，标记和清除两个过程效率都不高，另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，如果现在有一个对象占用的内存很大，这个时候必须要在执行一遍垃圾回收，为这个大的对象腾出空间。</p>
<p>复制算法：为了解决效率问题，出现了复制算法，这种算法把内存分为大小相等的两块，每次只是用其中的一块。当这一块内存用完了，就将还存活的对象复制到另一块上面，然后把已经使用过的那一块内存整个清理掉，这样使得每次清理的只是半个内存区域，内存分配时就不用考虑内存碎片等复杂的情况。实现简单，运行高效，但是缺点是，把内存缩小为原来的一半，代价有点高。</p>
<p>标记—-整理算法：和标记清除算法类似，只不过后续步骤不是直接对可回收对象进行清理，而是让存活的对象都向一端移动，然后直接清理到边界以外的内存空间。</p>
<p>分代收集算法：当前商业虚拟机(JVM)的垃圾收集都采用分代收集算法，根据对象存活周期的不同将内存划分为几块，一般把堆划分为新生代和老年代，这样就可以各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现大批对象死去，只有少量存活，就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集，而老年代中对象存活率高，就必须使用标记—-清理或者标记—-整理算法进行回收。</p>
<h3 id="6、-你是否用过Autowire注解，它的实现原理是什么"><a href="#6、-你是否用过Autowire注解，它的实现原理是什么" class="headerlink" title="6、****你是否用过Autowire注解，它的实现原理是什么****"></a><strong>6、***</strong>*你是否用过Autowire注解，它的实现原理是什么****</h3><p>@Autowired注解的作用是由AutowiredAnnotationBeanPostProcessor(注解解析器)实现的，查看该类的源码会发现它实现了MergedBeanDefinitionPostProcessor接口，进而实现了接口中的postProcessMergedBeanDefinition方法，@Autowired注解正是通过这个方法实现注入类型的预解析，将需要依赖注入的属性信息封装到InjectionMetadata类中，InjectionMetadata类中包含了哪些需要注入的元素及元素要注入到哪个目标类中。</p>
<p>Spring容器启动时，AutowiredAnnotationBeanPostProcessor被注册到容器；</p>
<p>扫描代码，如果带有@Autowired注解，则将依赖注入信息封装到InjectionMetadata中</p>
<p>创建bea时（实例化对象和初始化），会调用各种BeanPostProcessor对bean初始化，AutowiredAnnotationBeanPostProcessor负责将相关的依赖注入进来；</p>
<h3 id="7、-讲一讲java中的final和static以及你熟悉的Java中使用final修饰的类"><a href="#7、-讲一讲java中的final和static以及你熟悉的Java中使用final修饰的类" class="headerlink" title="\7、******讲一讲java中的final和static以及你熟悉的Java中使用final修饰的类****"></a><strong><em>\</em>7、*****</strong>*讲一讲java中的final和static以及你熟悉的Java中使用final修饰的类****</h3><p>static修饰变量（static是不能修饰局部变量的），就表示这个变量是静态的，全局共享的。</p>
<p>static修饰的方法（static是不能修饰构造方法的），就表示这个方法是静态的。但静态方法应该注意以下几点：</p>
<p>1、只能直接调用静态变量和今天方法，不能直接调用非静态变量和非静态方法。</p>
<p>2、不能使用this、super关键字。</p>
<p>3、不能被非静态方法覆盖。</p>
<p>static是不能修饰类的，但可以修饰内部类，称为静态内部类。静态内部类应该注意：</p>
<p>1、可以直接访问外部类的静态成员，不可以直接访问外部类的非静态成员。</p>
<p>2、非静态内部类只能定义非静态变量和方法，静态内部类可以定义静态和非静态的变量和方法。 </p>
<p>static修饰的代码块，称为静态块，静态块只会在类载入时执行一次。</p>
<p>当final修饰变量时，被修饰的变量必须被初始化(赋值)，且后续不能修改其值，实质上是常量；</p>
<p>当final修饰方法时，被修饰的方法无法被所在类的子类重写（覆写）；</p>
<p>当final修饰类时，被修饰的类不能被继承，并且final类中的所有成员方法都会被隐式地指定为final方法，但成员变量则不会变。</p>
<p>Java中使用final修饰的类：</p>
<p>java.lang包中</p>
<p>String,StringBuilder,StringBuffer</p>
<p>Boolean,Character,Short,Integer,Long,Float,Double,Byte,Void(八大类型的包装类型加一个void)</p>
<p>java.util包</p>
<p>UUID,Scanner</p>
<p>java.lang.reflect包</p>
<p>Array,Constructor,Field,Parameter</p>
<h3 id="8、-讲讲Java中线程安全的问题，以及常用的一些手段控制线程安全包括他们的优劣势"><a href="#8、-讲讲Java中线程安全的问题，以及常用的一些手段控制线程安全包括他们的优劣势" class="headerlink" title="\8、******讲讲Java中线程安全的问题，以及常用的一些手段控制线程安全包括他们的优劣势****"></a><strong><em>\</em>8、*****</strong>*讲讲Java中线程安全的问题，以及常用的一些手段控制线程安全包括他们的优劣势****</h3><p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是<a href="https://www.baidu.com/s?wd=线程安全&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">线程安全</a>的，反之不安全。</p>
<p>synchronized关键字</p>
<p>当synchronized锁住一个对象之后，别的线程如果想要获取锁对象，那么就必须等这个线程执行完释放锁对象之后才可以，否则一直处于等待状态。缺点，如果随意使用时很影响程序的性能，别的对象想拿到锁，结果你没用锁还一直把锁占用，这样就有点浪费资源。</p>
<p>Lock</p>
<p>我们在需要的时候去手动的获取锁和释放锁，甚至我们还可以中断获取以及超时获取的同步特性，但是从使用上说Lock明显没有synchronized使用起来方便快捷。</p>
<h3 id="9、-线程安全的单例模式是怎么实现的？-原理是什么？"><a href="#9、-线程安全的单例模式是怎么实现的？-原理是什么？" class="headerlink" title="9、****线程安全的单例模式是怎么实现的？ 原理是什么？****"></a><strong>9、***</strong>*线程安全的单例模式是怎么实现的？ 原理是什么？****</h3><p>单例模式是常见的设计模式之一：目的是节省内存，限制了实例的个数；有利于java GC回收机制。</p>
<p>单例模式分类:</p>
<p>饿汉模式（在类加载时便会创建对象、如果方法没有synchronized，则线程不    安全）；</p>
<p>　　懒汉模式（在外部第一次请求实例时才会创建实例,线程安全）；</p>
<p>1.懒汉模式：类加载时不会初始化，当外部第一次请求实例时才会创建实例；而且第一次创建后不            在创建该实例；但是这种模式的问题是内存中不管会不会用到这个对象，它都一直在那放着</p>
<p>　　　　特点是：运行时获取对象的速度比较慢，但加载的时候比较快，它在整个生命的应用周        期只占用一部分资源</p>
<p>2.饿汉模式：类加载时就会初始化，创建实例；</p>
<p>　　　　　　特点是：运行时获取对象速度比较快，但加载时速度比较慢，会一直占用资源 （程            序打开加载比较慢，但运行速度快—从用户体验角度来说推荐饿汉）</p>
<h3 id="10、-java中几种集合的区别以及底层实现是什么样的？"><a href="#10、-java中几种集合的区别以及底层实现是什么样的？" class="headerlink" title="10、****java中几种集合的区别以及底层实现是什么样的？****"></a><strong>10、***</strong>*java中几种集合的区别以及底层实现是什么样的？****</h3><p>ArrayList是基于数组的，在初始化ArrayList时，会构建空数组（Object[] elementData={}）。ArrayList是一个无序的，它是按照添加的先后顺序排列，当然，他也提供了sort方法，如果需要对ArrayList进行排序，只需要调用这个方法，提供Comparator比较器即可</p>
<p>add操作：</p>
<p>1）如果是第一次添加元素，数组的长度被扩容到默认的capacity，也就是10.</p>
<p>2) 当发觉同时添加一个或者是多个元素，数组长度不够时，就扩容，这里有两种情况：</p>
<p>只添加一个元素，例如：原来数组的capacity为10，size已经为10，不能再添加了。需要扩容，新的capacity=old capacity+old capacity&gt;&gt;1=10+10/2=15.即新的容量为15。</p>
<p>当同时添加多个元素时，原来数组的capacity为10，size为10，当同时添加6个元素时。它需要的min capacity为16，而按照capacity=old capacity+old capacity&gt;&gt;1=10+10/2=15。new capacity小于min capacity，则取min capacity。</p>
<p>对于添加，如果不指定下标，就直接添加到数组后面，不涉及元素的移动，如果要添加到某个特定的位置，那需要将这个位置开始的元素往后挪一个位置，然后再对这个位置设置。</p>
<p>HashMap</p>
<p>Jdk1.7中，HashMap底层基于数组+链表实现，如果entry放的位置在数组中都是同一个位置，链表就会变得很长，链表深度过深将导致效率低下！</p>
<p>因此在Jdk1.8中，为了解决链表深度过深导致的效率低下问题，HashMap底层结构变为数组+链表+红黑树实现。当链表的长度    大于等于8时，链表转换为</p>
<p>红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。特点：</p>
<p>\1. 每个节点要么是红色，要么是黑色。</p>
<p>\2. 根节点必须是黑色</p>
<p>\3. 红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。</p>
<p>\4. 对于每个节点，从该点至null（树尾端）的任何路径，都含有相同个数的黑色节点。</p>
<p>HashMap提供了4个构造函数：</p>
<p>HashMap()：构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。</p>
<p>HashMap(int initialCapacity)：构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。</p>
<p>HashMap(int initialCapacity, float loadFactor)：构造一个带指定初始容量和加载因子的空 HashMap。</p>
<p>HashMap(Map&lt;? extends K, ? extends V&gt; m)：传入一个map以构造一个新的map，使用默认加载因子（0.75）。</p>
<p>  在这里提到了两个参数：初始容量，加载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。</p>
<p><strong><em>\</em>存值put(K key, V value)**</strong></p>
<p>public V put(K key, V value) {  return putVal(hash(key), key, value, false, true);  }  </p>
<p>final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</p>
<p>​          boolean evict) {</p>
<p>​    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</p>
<p>​        //检测table是否为空，如果为空，则使用扩容函数进行初始化</p>
<p>​    if ((tab = table) == null || (n = tab.length) == 0)        <strong><em>\</em>A**</strong></p>
<p>​      n = (tab = resize()).length;</p>
<p>​        //如果通过hash值取模得到的桶为空，则直接把新生成的节点放入该桶</p>
<p>​    if ((p = tab[i = (n - 1) &amp; hash]) == null)    <strong><em>\</em>B**</strong></p>
<p>​      tab[i] = newNode(hash, key, value, null);</p>
<p>​    else {//以下为该桶不为空的逻辑</p>
<p>​      Node&lt;K,V&gt; e; K k;</p>
<p>​            //判断桶的第一个元素的key值是否相同（hash值相同，且能equals）</p>
<p>​            //如果相同，则返回当前元素（函数末尾进行统一处理）</p>
<p>​      if (p.hash == hash &amp;&amp;</p>
<p>​        ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))    <strong><em>\</em>C**</strong></p>
<p>​        e = p;</p>
<p>​      else if (p instanceof TreeNode)//桶元素采用的是红黑树结构    <strong><em>\</em>D**</strong></p>
<p>​        e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</p>
<p>​      else {//桶元素采用的是链表结构</p>
<p>​        for (int binCount = 0; ; ++binCount) {        <strong><em>\</em>E**</strong></p>
<p>​                    //如果遍历到了链表末端，则直接在链表末端插入新元素</p>
<p>​          if ((e = p.next) == null) {</p>
<p>​            p.next = newNode(hash, key, value, null);</p>
<p>​                        //插入之后，检查是否达到了转成红黑树结构的标准</p>
<p>​            if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st    <strong><em>\</em>F**</strong></p>
<p>​              treeifyBin(tab, hash);</p>
<p>​            break;</p>
<p>​          }</p>
<p>​                    //如果在遍历过程中，发现了key值相同，则返回当前元素（函数末尾进行统一处理）</p>
<p>​          if (e.hash == hash &amp;&amp;        <strong><em>\</em>G**</strong></p>
<p>​            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</p>
<p>​            break;</p>
<p>​          p = e;</p>
<p>​        }</p>
<p>​      }</p>
<p>​            //处理相同元素的情况</p>
<p>​      if (e != null) { // existing mapping for key        <strong><em>\</em>H**</strong></p>
<p>​        V oldValue = e.value;</p>
<p>​                //如果onlyIfAbsent为ture，则在oldValue为空时才替换</p>
<p>​                //否则直接替换</p>
<p>​        if (!onlyIfAbsent || oldValue == null)</p>
<p>​          e.value = value;</p>
<p>​        afterNodeAccess(e);</p>
<p>​        return oldValue;</p>
<p>​      }</p>
<p>​    }</p>
<p>​    ++modCount;//修改次数+1</p>
<p>​        //map的size加1，然后判断是否达到了threshold，否则进行扩容</p>
<p>​        //threshold由Node[] table的长度及loadFactor控制</p>
<p>​    if (++size &gt; threshold)        <strong><em>\</em>I**</strong></p>
<p>​      resize();</p>
<p>​        //执行回调函数</p>
<p>​    afterNodeInsertion(evict);</p>
<p>​    return null;</p>
<p>}</p>
<p>A. 判断当前桶是否为空，空的就需要初始化（resize 中会判断是否进行初始化）。</p>
<p>B. 根据当前 key 的 hashcode 定位到具体的桶中并判断是否为空，为空表明没有 Hash 冲突就直接在当前位置创建一个新桶即可。</p>
<p>C. 如果当前桶有值（ Hash 冲突），那么就要比较当前桶中的 key、key 的 hashcode 与写入的 key 是否相等，相等就赋值给 e,在第 8 步的时候会统一进行赋值及返回。</p>
<p>D. 如果当前桶为红黑树，那就要按照红黑树的方式写入数据。</p>
<p>E. 如果是个链表，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表）。</p>
<p>F. 接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。</p>
<p>G. 如果在遍历过程中找到 key 相同时直接退出遍历。</p>
<p>H. 如果 e != null 就相当于存在相同的 key,那就需要将值覆盖。</p>
<p>I. 最后判断是否需要进行扩容。</p>
<h3 id><a href="#" class="headerlink" title></a></h3><h2 id="第三天"><a href="#第三天" class="headerlink" title="\第三天**"></a><strong><em>\</em>第三天**</strong></h2><h3 id="1、聊聊Java中序列化以及反序列的作用，类序列化时类的版本号的用途，如果没有指定一个版本号，系统是怎么处理的？如果加了字段会怎么样？"><a href="#1、聊聊Java中序列化以及反序列的作用，类序列化时类的版本号的用途，如果没有指定一个版本号，系统是怎么处理的？如果加了字段会怎么样？" class="headerlink" title="\1、聊聊Java中序列化以及反序列的作用，类序列化时类的版本号的用途，如果没有指定一个版本号，系统是怎么处理的？如果加了字段会怎么样？**"></a><strong><em>\</em>1、聊聊Java中序列化以及反序列的作用，类序列化时类的版本号的用途，如果没有指定一个版本号，系统是怎么处理的？如果加了字段会怎么样？**</strong></h3><p>答：</p>
<p>序列化是将对象状态转换为可保持或传输的形式的过程。 序列化的补集是反序列化，后者将流转换为对象。 这两个过程一起保证数据易于存储和传输。</p>
<p>版本号得作用：就是确保了不同版本之间的兼容性，不仅能够向前兼容，还能够向后兼容，即在版本升级时反序列化仍保持对象的唯一性。如果没有显式声明序列号，那么在程序编译时会自己生成这个版本序列号，如果加了字段，更改了实体类的时候又会重新生成一个序列号。</p>
<h3 id="2、介绍一下MyBatis的缓存？"><a href="#2、介绍一下MyBatis的缓存？" class="headerlink" title="\2、介绍一下MyBatis的缓存？**"></a><strong><em>\</em>2、介绍一下MyBatis的缓存？**</strong></h3><p>答：</p>
<p>MyBatis提供了一级缓存和二级缓存。</p>
<p>一级缓存：也称为本地缓存，用于保存用户在一次会话过程中查询的结果，用户一次会话中只能使用一个sqlSession，一级缓存是自动开启的，不允许关闭。</p>
<p>二级缓存：也称为全局缓存，是mapper级别的缓存，是针对一个表的查结果的存储，可以共享给所有针对这张表的查询的用户。也就是说对于mapper级别的缓存不同的sqlsession是可以共享的。</p>
<h3 id="3、讲一讲javaWeb中的四种会话跟踪技术"><a href="#3、讲一讲javaWeb中的四种会话跟踪技术" class="headerlink" title="\3、讲一讲javaWeb中的四种会话跟踪技术**"></a><strong><em>\</em>3、讲一讲javaWeb中的四种会话跟踪技术**</strong></h3><p>答：</p>
<p>会话跟踪：主要解决HTTP的无状态问题，指用户在同一网站的多个页面之间转换时，根本无法确定是否是同一个客户，会话跟踪技术就可以解决这个问题。当一个客户在多个页面间切换时，服务器会保存该用户的信息。</p>
<p>1、Cookie：服务端向客户端储存的会话标识符，当用户产生请求时会以请求头的形式发往服务端，从而判断用户</p>
<p>2、URL重写：客户程序在每个URL的尾部添加一些额外数据。这些数据标识当前的会话，服务器将这个标识符与它存储的用户相关数据关联起来，从而判断用户</p>
<p>3、隐藏的表单域：将有关用户的会话信息放到隐藏的表单列中，通过表单提交到服务端，从而判断杨亚辉</p>
<p>4、session:信息保存在服务器端，使用 setAttribute(String str,Object obj)方法将对象捆绑到一个会话</p>
<h3 id="4、描述一下JVM加载class文件的原理机制"><a href="#4、描述一下JVM加载class文件的原理机制" class="headerlink" title="\4、描述一下JVM加载class文件的原理机制?**"></a><strong><em>\</em>4、描述一下JVM加载class文件的原理机制?**</strong></h3><p>答：</p>
<p>JVM中类的加载是由类加载器（ClassLoader）和它的子类来实现的。Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。</p>
<p>由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。</p>
<p>一、类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后Class对象还不完整，所以此时的类还不可用。</p>
<p>二、当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。</p>
<p>三、最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。</p>
<h3 id="5、同步和异步有什么异同，在什么情况下分别使用他们？举例说明"><a href="#5、同步和异步有什么异同，在什么情况下分别使用他们？举例说明" class="headerlink" title="\5、同步和异步有什么异同，在什么情况下分别使用他们？举例说明**"></a><strong><em>\</em>5、同步和异步有什么异同，在什么情况下分别使用他们？举例说明**</strong></h3><p>答：</p>
<p>同步请求：发送一个请求需要等待返回才能够发送下一个请求有等待过程；</p>
<p>异步请求：发送一个请求，不需要等待随时可已发送下一条请求；</p>
<p>如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。</p>
<p>当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。</p>
<h3 id="6、请说出你所知道的线程同步的方法"><a href="#6、请说出你所知道的线程同步的方法" class="headerlink" title="\6、请说出你所知道的线程同步的方法**"></a><strong><em>\</em>6、请说出你所知道的线程同步的方法**</strong></h3><p>答：</p>
<p>同步是一种各线程间协调使用共享资源的一种方式。各线程间的相互通信是实现同步的重要因素，</p>
<p>所以 Java 提供了 wait()和 notify()等方法来使线程之间可以相互通信。</p>
<p>q</p>
<p>1、wait()：使线程处于等待状态，并且释放所持有的对象的 lock。可以与 notify()方法配套使用。</p>
<p>它有两种形式，一种是以毫秒为单位的一段时间作为参数，另一种是没有参数。</p>
<p>q</p>
<p>2、 sleep()：使一个正在运行的线程处于阻塞状态，可以以毫秒为单位的一段时间作为参数，它可</p>
<p>以使得线程在设定的时间停止运行，但是在设定的时间一过，线程重新进入可执行状态。由于</p>
<p>sleep()是一个静态方法，所以调用此方法要捕捉 InterruptedException 异常。</p>
<p>q </p>
<p>3、notify()：唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某</p>
<p>一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且不是按优先级。</p>
<p>q</p>
<p>4、allnotity()：唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让</p>
<p>它们竞争。只有获得锁的那一个线程才能进入可执行状态。</p>
<p>5、用 synchronized 修饰需要同步的方法或者用 synchronized 块包围需要同步的语句</p>
<h3 id="7、什么是aop，aop的作用是什么-aop中的关键名词有些那些，相互关系是什么"><a href="#7、什么是aop，aop的作用是什么-aop中的关键名词有些那些，相互关系是什么" class="headerlink" title="\7、什么是aop，aop的作用是什么?aop中的关键名词有些那些，相互关系是什么?**"></a><strong><em>\</em>7、什么是aop，aop的作用是什么?aop中的关键名词有些那些，相互关系是什么?**</strong></h3><p>答：</p>
<p>AOP指面向切片编程，AOP通过预编译方式和运行期动态代理实现，在不修改源代码的情况下，给程序动态统一添加功能的一种技术，简称AOP。是spring框架的一个重要内容，是OOP（面向对象编程）的衍生模范型。</p>
<p>作用：利用AOP对业务逻辑的各个部分进行隔离，降低业务逻辑的耦合性，提高程序的可重用型和开发效率。</p>
<p>名词，关系：拦截器: 代理 ，装备(advice) ，目标对象 ，关切点:条件 ，连接点:方法、属性 </p>
<h3 id="8、在spring中有几种事务管理，分别是什么"><a href="#8、在spring中有几种事务管理，分别是什么" class="headerlink" title="\8、在spring中有几种事务管理，分别是什么?**"></a><strong><em>\</em>8、在spring中有几种事务管理，分别是什么?**</strong></h3><p>答：</p>
<p>1，Spring有两种事务管理方式：①编程式 ②声明式。编程式的比较灵活，但是代码量大，存在重复的代码比较多；而声明式事务管理比编程式更灵活方便。</p>
<p>基于AOP的声明式事务管理，实质就是在方法执行前后进行拦截，然后在方法执行前创建并加入事务，执行完目标方法后根据执行情况提交事务或者回滚事务。</p>
<p>声明式事务管理有两种形式：①配置文件 ②在业务方法上加上@Transaction注解，将事务规则应用到业务逻辑中。</p>
<p>2，Spring的事务管理接口主要有三个：TransactionDefinition、Platform TransactionManager、Transaction Status。</p>
<h3 id="9、String类为什么是final的？"><a href="#9、String类为什么是final的？" class="headerlink" title="\9、String类为什么是final的？**"></a><strong><em>\</em>9、String类为什么是final的？**</strong></h3><p>答：</p>
<p>首先要了解final，final可以修饰类，方法和变量，并且被修饰的类或方法，被final修饰的类不能被继承，即它不能拥有自己的子类，被final修饰的方法不能被重写， final修饰的变量，无论是类属性、对象属性、形参还是局部变量，都需要进行初始化操作。</p>
<p>原因：主要是为了”安全性“和”效率“的缘故</p>
<p>由于String类不能被继承，所以就不会被修改，这就避免了因为继承引起的安全隐患；</p>
<p>String类在程序中出现的频率比较高，如果为了避免安全隐患，在它每次出现时都用final来修饰，这无疑会降低程序的执行效率，所以干脆直接将其设为final一提高效率；</p>
<p>因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。</p>
<p>因为字符串是不可变的，所以在它创建的时候HashCode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</p>
<h3 id="10、session和cookie的区别和联系，session的生命周期，多个服务部署时session管理"><a href="#10、session和cookie的区别和联系，session的生命周期，多个服务部署时session管理" class="headerlink" title="\10、session和cookie的区别和联系，session的生命周期，多个服务部署时session管理**"></a><strong><em>\</em>10、session和cookie的区别和联系，session的生命周期，多个服务部署时session管理**</strong></h3><p>答：</p>
<p>区别：session保存在服务端，而cookie保存在客户端；cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。cookie的生命周期受到 cookie 自身生命周期以及客户端是否保留 cookie 文件的影响；session的生命周期受到 session 自身的存活周期以及客户端连接是否关闭的影响；单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie；session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。</p>
<p>联系：session和cookie的作用有点类似，都是为了存储用户相关的信息，session的sessionId可以通过cookie保存</p>
<p>生命周期：Tomcat中Session的默认失效时间为20分钟，Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session， 服务器会把长时间没有活动的Session从服务器内存中清除，此时Session便失效</p>
<p>管理：通过redis缓存技术，管理session，实现session共享</p>
<h2 id="第四天"><a href="#第四天" class="headerlink" title="\第四天**"></a><strong><em>\</em>第四天**</strong></h2><h3 id="1、-为什么重写equals时必须重写hashCode方法？"><a href="#1、-为什么重写equals时必须重写hashCode方法？" class="headerlink" title="1、****为什么重写equals时必须重写hashCode方法？****"></a><strong>1、***</strong>*为什么重写equals时必须重写hashCode方法？****</h3><p>hashCode()和equals()保持一致，如果equals方法返回true，那么两个对象的hasCode()返回值必须一样。如果equals方法返回false，hashcode不要求不一样，但是这样不利于哈希表的性能，一般我们也不要这样做。重写equals()方法就必须重写hashCode()方法的原因也就显而易见了。</p>
<p>  假设两个对象，重写了其equals方法，其相等条件是属性相等，就返回true。如果不重写hashcode方法，其返回的依然是两个对象的内存地址值，必然不相等。这就出现了equals方法相等，但是hashcode不相等的情况。这不符合hashcode的规则。</p>
<h3 id="2、-Java-中的异常分类和处理机制"><a href="#2、-Java-中的异常分类和处理机制" class="headerlink" title="2、****Java 中的异常分类和处理机制****"></a><strong>2、***</strong>*Java 中的异常分类和处理机制****</h3><p>Throwable是JAVA语言中所有错误或异常的超类，下一层分为error或者Exception。</p>
<p>Error类是指系统的内部错误和资源耗尽的错误，应用程序不会抛出该类对象，如果出现这样的错误，应用程序会尽量让程序安全的终止。</p>
<p>Exception又 有 两 个 分 支 ， 一 个 是 运 行 时 异 常 RuntimeException ， 一 个 是 检查异常CheckedException。</p>
<p> RuntimeException：在定义方法时不需要声明会抛出RuntimeException， 在调用这个方法时不需要捕获这个RuntimeException；总之，未检查异常不需要try…catch…或throws 机制去处理<br>     CheckedException：定义方法时必须声明所有可能会抛出的exception； 在调用这个方法时，必须捕获它的checked exception，不然就得把它的exception传递下去<br>总之，一个方法必须声明所有的可能抛出的已检查异常；未检查异常要么不可控制（Error），要么应该避免（RuntimeException）。如果方法没有声明所有的可能发生的已检查异常，编译器就会给出错误信息</p>
<p>处理异常的方法</p>
<p>抛给调用者</p>
<p>有三种方式，throw，throws，系统自动抛异常</p>
<p>Throw和throws的区别：<br>    1. 位置不同：throws用在函数上，后面跟的是异常类，可以跟多个；而throw用在函数内，后    面跟的是异常对象。<br>    2. 功能不同：throws用来声明异常，让调用者只知道该功能可能出现的问题，可以给出预先的处理方式；throw抛出具体的问题对象，执行到throw，功能就已经结束了，跳转到调用者，并    将具体的问题对象抛给调用者。也就是说throw语句独立存在时，下面不要定义其他语句，因    为执行不到。<br>    3. throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行    throw则一定抛出了某种异常对象。<br>    4. 两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出    异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。 </p>
<p>2、捕获异常  try..catch</p>
<h3 id="3、-Java序列化中如果有些字段不想进行序列化-怎么办"><a href="#3、-Java序列化中如果有些字段不想进行序列化-怎么办" class="headerlink" title="\3、******Java序列化中如果有些字段不想进行序列化 怎么办****"></a><strong><em>\</em>3、*****</strong>*Java序列化中如果有些字段不想进行序列化 怎么办****</h3><p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p>
<p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。</p>
<h3 id="4、-讲讲Java中的字符串不可变和字符串池"><a href="#4、-讲讲Java中的字符串不可变和字符串池" class="headerlink" title="4、*****讲讲Java中的字符串不可变和字符串池****"></a><strong><em>4、****</em></strong>*讲讲Java中的字符串不可变和字符串池****</h3><p>1、String类型在实现时，其内部成员变量全部使用final来修饰，保证成员变量的引用值只能通过构造函数来修改；<br>2、String类型在实现时，在外部可能修改其内部存储值的函数实现中，返回时一律构造新的String对象或者新的byte数组或者char数组；</p>
<p><img src="/2019/12/27/hellWorld/C:%5CUsers%5C23349%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200423192927470.png" alt="image-20200423192927470"><br>第2的重要性在于，假如通过String类型的toCharArray方法可以直接访问String类型内部定义的char数组，那么即便String类型内部的char数组使用了final来修饰，也仅仅保证这个成员变量的引用不可变，而无法保证引用指向的内存区域不可变。由上述两点，保证外部不可能修改java.lang.String类型对象的内部属性，从而保证String对象是不可变的</p>
<p><strong><em>\</em>为什么会将 String 设计为不可变**</strong></p>
<p>安全</p>
<p>引发安全问题，譬如，数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接，或者在socket编程中，主机名和端口都是以字符串的形式传入。因为字符串是不可变的，所以它的值是不可改变的，否则黑客们可以钻到空子，改变字符串指向的对象的值，造成安全漏洞</p>
<p>保证线程安全，在并发场景下，多个线程同时读写资源时，会引竞态条件，由于 String 是不可变的，不会引发线程的问题而保证了线程</p>
<p>HashCode，当 String 被创建出来的时候，hashcode也会随之被缓存，hashcode的计算与value有关，若 String 可变，那么 hashcode 也会随之变化，针对于 Map、Set 等容器，他们的键值需要保证唯一性和一致性，因此，String 的不可变性使其比其他对象更适合当容器的键值。</p>
<p>性能</p>
<p>当字符串是不可变时，字符串常量池才有意义。字符串常量池的出现，可以减少创建相同字面量的字符串，让不同的引用指向池中同一个字符串，为运行时节约很多的堆内存。若字符串可变，字符串常量池失去意义，基于常量池的String.intern()方法也失效，每次创建新的 String 将在堆内开辟出新的空间，占据更多的内存</p>
<p>String A=“string”，String B = A，A=“string2”</p>
<p>可以发现A重新赋值后保存了新的引用，而不是在原来的基础上进行数据改变，同时B仍然存储的是“String”，两个变量相互独立，不影响。这说明了String对象的不可变</p>
<p>A和B只存储了String对象的引用，A存储的是指向对象所在内存的地址引用，A第二次赋值时引用指向了“string2”的内存地址，“string”对象依然存在内存中，由B引用。</p>
<p>String类的返回String对象的方法也都不会改变自身，返回一个新的String对象，如concat、replace</p>
<p>在Java中有两种创建字符串对象的方式：</p>
<p>1）采用字面值的方式赋值     两个值一样的变量使用==返回true</p>
<p>采用字面值的方式创建一个字符串时，JVM首先会去字符串池中查找是否存在”aaa”这个对象，如果不存在，则在字符串池中创建”aaa”这个对象，然后将池中”aaa”这个对象的引用地址返回给字符串常量str，这样str会指向池中”aaa”这个字符串对象；如果存在，则不创建任何对象，直接将池中”aaa”这个对象的地址返回，赋给字符串常量。</p>
<p> 2）采用new关键字新建一个字符串对象  两个值一样的变量使用==返回false</p>
<p> 采用new关键字新建一个字符串对象时，JVM首先在字符串池中查找有没有”aaa”这个字符串对象，如果有，则不在池中再去创建”aaa”这个对象了，直接在堆中创建一个”aaa”字符串对象，然后将堆中的这个”aaa”对象的地址返回赋给引用str3，这样，str3就指向了堆中创建的这个”aaa”字符串对象；如果没有，则首先在字符串池中创建一个”aaa”字符串对象，然后再在堆中创建一个”aaa”字符串对象，然后将堆中这个”aaa”字符串对象的地址返回赋给str3引用，这样，str3指向了堆中创建的这个”aaa”字符串对象。</p>
<p>字符串池的实现有一个前提条件：String对象是不可变的。因为这样可以保证多个引用可以同事指向字符串池中的同一个对象。如果字符串是可变的，那么一个引用操作改变了对象的值，对其他引用会有影响，这样显然是不合理的。</p>
<p> <strong><em>\</em>字符串池的优缺点**</strong>：字符串池的优点就是避免了相同内容的字符串的创建，节省了内存，省去了创建相同字符串的时间，同时提升了性能；另一方面，字符串池的缺点就是牺牲了JVM在常量池中遍历对象所需要的时间，不过其时间成本相比而言比较低。</p>
<h3 id="5、-线程中wait-和sleep-的区别？"><a href="#5、-线程中wait-和sleep-的区别？" class="headerlink" title="5、****线程中wait 和sleep 的区别？****"></a><strong>5、***</strong>*线程中wait 和sleep 的区别？****</h3><p>Sleep方法：</p>
<p>线程主动放弃CPU，使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，指定的时间一过，线程重新进入可执行状态。典型地，sleep()被用在等待某个资源就绪的情形：测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。</p>
<p>Wait方法 ：</p>
<p>与notify()配套使用，wait()使得线程进入阻塞状态，它有两种形式，一种允许指定以毫秒为单位的一段时间作为参数，另一种没有参数，当指定时间参数时对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，后者则必须对应的 notify() 被调用。</p>
<p><strong><em>\</em>sleep与wait都可以使线程等待，但sleep不会释放资源而wait会释放资源。**</strong></p>
<h3 id="6、-List-和-Set-的区别？"><a href="#6、-List-和-Set-的区别？" class="headerlink" title="6、****List 和 Set 的区别？****"></a><strong>6、***</strong>*List 和 Set 的区别？****</h3><p>list ——其中的值允许重复，因为它是有自己的排序规则的数据结构</p>
<p> ArrayList: 写入数据时，数据在尾部的时候快，取数快</p>
<p> LinkedList:  集合中间部分添加值和删除值得时候快</p>
<p>Set——其中的值不允许重复，无序的数据结构 </p>
<p>一个不包含重复元素（值）的 collection，set在每次添加元素（值）的时候，都会把前面的元素和新增的元素进行比较，如果是true，重复，丢弃；false：添加到集合当中。</p>
<p>List适合经常追加数据，插入，删除数据。但随机取数效率比较低。</p>
<p>Set适合经常地随机储存，插入，删除。但是在遍历时效率比较低。</p>
<h3 id="7、-HashSet-是如何保证不重复的"><a href="#7、-HashSet-是如何保证不重复的" class="headerlink" title="7、****HashSet 是如何保证不重复的****"></a><strong>7、***</strong>*HashSet 是如何保证不重复的****</h3><p>HashSet底层的add方法其实是把元素放在了map中，用元素值作为map的key，而map的key是不能重复的，所以HashSet不能重复</p>
<h3 id="8、-java中数组在内存中如何分配？"><a href="#8、-java中数组在内存中如何分配？" class="headerlink" title="8、****java中数组在内存中如何分配？****"></a><strong>8、***</strong>*java中数组在内存中如何分配？****</h3><p>数组必须经过初始化才可使用。所谓初始化，即创建实际的数组对象，也就是在内存中为数组对象分配内存空间，并为每个数组 元素指定初始值。</p>
<p>数组的初始化有以下两种方式。</p>
<p>·<strong><em>\</em>静态初始化**</strong>：初始化时由程序员显式指定每个数组元素的初始值，由系统决定数组长度。</p>
<p>·<strong><em>\</em>动态初始化**</strong>：初始化时程序员只指定数组长度，由系统为数组元素分配初始值。</p>
<p>不管采用哪种方式初始化Java 数组，一旦初始化完成，该数组的长度就不可改变</p>
<p>局部变量存储在栈中，new出来的东西存储在堆中</p>
<p>在堆内存中每一个 new 出来的对象都有一个唯一的地址值，就如同</p>
<p>int[] arr；            栈</p>
<p>arr= new int[3];        堆</p>
<p> 相当于把堆内存的地址值赋值给栈内存的的数组。堆内存每一个对象的数据类型都有默认值(在没有赋值的情况下)。栈内存通过地址值找到堆内存对应的地址值，然后通过索引找到对应的数值。</p>
<h3 id="9、-什么是多线程环境下的伪共享（false-sharing）？"><a href="#9、-什么是多线程环境下的伪共享（false-sharing）？" class="headerlink" title="9、****什么是多线程环境下的伪共享（false sharing）？****"></a><strong>9、***</strong>*什么是多线程环境下的伪共享（false sharing）？****</h3><p>在程序运行的过程中，缓存每次更新都从主内存中加载连续的 64 个字节。因此，如果访问一个 long 类型的数组时，当数组中的一个值被加载到缓存中时，另外 7 个元素也会被加载到缓存中。</p>
<p>但是，如果使用的数据结构中的项在内存中不是彼此相邻的，比如链表，那么将得不到免费缓存加载带来的好处。</p>
<p>不过，这种免费加载也有一个坏处。设想如果我们有个 long (8个字节)类型的变量 a，它不是数组的一部分，而是一个单独的变量，并且还有另外一个 long 类型的变量 b 紧挨着它，那么当加载 a 的时候将免费加载 b。</p>
<p>看起来似乎没有什么毛病，但是如果一个 CPU 核心的线程在对 a 进行修改，另一个 CPU 核心的线程却在对 b 进行读取。</p>
<p>当前者修改 a 时，会把 a 和 b 同时加载到前者核心的缓存行中，更新完 a 后其它所有包含 a 的缓存行都将失效，因为其它缓存中的 a 不是最新值了。</p>
<p>而当后者读取 b 时，发现这个缓存行已经失效了，需要从主内存中重新加载。</p>
<p>请记住，我们的缓存都是以缓存行作为一个单位来处理的，所以失效 a 的缓存的同时，也会把 b 失效，反之亦然。</p>
<p>这样就出现了一个问题，b 和 a 完全不相干，每次却要因为 a 的更新需要从主内存重新读取，它被缓存未命中给拖慢了。</p>
<p>这就是传说中的伪共享。</p>
<p>1.共享就是一个内存区域的数据被多个处理器访问，伪共享就是 不是真的共享。</p>
<p>这里的共享这个概念是基于逻辑层面的。实际上伪共享与共享在cache line 上实际都是共享的。</p>
<p>2.CPU访问的数据都是从cache line  中读取的。如果cpu 在cache 中找不到需要的变量，则称缓存未命中。</p>
<p>未命中时，需要通过总线从内存中读取进cache 中。每次读取的内存大小就是一个cache line 的大小。</p>
<p>3.如果多个CPU访问的不同内存变量被装载到了同一个cache line 中，则从程序逻辑层上讲，并没有共享变量，</p>
<p>但实际上在cache line 上他们是共享访问的，这个就是典型的伪共享。</p>
<p>4.伪共享与共享 在 cache line 的层面上必须都是共享的。多个CPU对共享内存的访问安全通过缓存一致性来保证。</p>
<h3 id="10、-解释Java堆空间及GC"><a href="#10、-解释Java堆空间及GC" class="headerlink" title="10、****解释Java堆空间及GC****"></a><strong>10、***</strong>*解释Java堆空间及GC****</h3><p>我们由GC的角度来进行堆内存的区域划分：<strong><em>\</em>新生代**</strong>和<strong><em>\</em>老年代*****</strong>*(*<strong><em>新生代空间不足，会直接将大对象存放在老年代</em></strong>*)*<strong><em>。而新生代又可以划分为</em></strong>*Eden区*<strong><em>、</em></strong>*SurvivorFrom区*<strong><em>、</em></strong>*SurvivorTo区*<strong><em>。而整个区域的比例应该是新生代比老年代为</em></strong>*1:2*<strong><em>，而Eden比SurvivorFrom比SurvivorTo为</em></strong>*8:1:1****。</p>
<p>新创建的对象存储在新生代中的Eden区，eden区也是新生代的主要内存区；Eden区的对象经过一次GC后依然存活的对象会进入from区，from区经过一次GC后将存活的对象存入to区，to区经过一次GC后会将存活的对象存入from区。这里from区和to区不是固定的，而是会随着GC算法相互转化，from区可以为to区，to区可以为from区。严格的来说，都是from区经过一次GC后，将存活的对象存入to区。而from区和to区的对象经过若干次GC后(默认15次)，如果依然存活，则会进入到老年代。而判断一个类是否死亡，需同时满足三个条件：</p>
<p>（1）、该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</p>
<p> （2）、加载该类的ClassLoader已经被回收</p>
<p> （3）、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>
<h2 id="第五天"><a href="#第五天" class="headerlink" title="\第五天**"></a><strong><em>\</em>第五天**</strong></h2><h3 id="1、-java中操作字符串都有哪些类？它们之间有什么区别？"><a href="#1、-java中操作字符串都有哪些类？它们之间有什么区别？" class="headerlink" title="1、****java中操作字符串都有哪些类？它们之间有什么区别？****"></a><strong>1、***</strong>*java中操作字符串都有哪些类？它们之间有什么区别？****</h3><p>String : final修饰，String类的方法都是返回new String。即对String对象的任何改变都不影响到原对象，对字符串的修改操作都会生成新的对象。</p>
<p>StringBuffer : 对字符串的操作的方法都加了synchronized，保证线程安全。</p>
<p>StringBuilder : 不保证线程安全，在方法体内需要进行字符串的修改操作，可以new StringBuilder对象，调用StringBuilder对象的append、replace、delete等方法修改字符串。</p>
<h3 id="2、-BIO、NIO、AIO-有什么区别？"><a href="#2、-BIO、NIO、AIO-有什么区别？" class="headerlink" title="2、****BIO、NIO、AIO 有什么区别？****"></a><strong>2、***</strong>*BIO、NIO、AIO 有什么区别？****</h3><p><strong><em>\</em>一、同步阻塞I/O(BIO)：**</strong></p>
<p>同步阻塞I/O，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制来改善。BIO方式适用于连接数目比较小且固定的架构，这种方式对服务端资源要求比较高，并发局限于应用中，在jdk1.4以前是唯一的io现在，但程序直观简单易理解</p>
<p><strong><em>\</em>二、同步非阻塞I/O(NIO)：**</strong></p>
<p>同步非阻塞I/O，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理。NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，jdk1,4开始支持</p>
<p><strong><em>\</em>三、异步非阻塞I/O(AIO)：**</strong></p>
<p>异步非阻塞I/O，服务器实现模式为一个有效请求一个线程，客户端的IO请求都是由操作系统先完成了再通知服务器用其启动线程进行处理。AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，jdk1.7开始支持。</p>
<h3 id="3、-？并简线程有哪些状态单解释一下每个状态"><a href="#3、-？并简线程有哪些状态单解释一下每个状态" class="headerlink" title="3、****？并简线程有哪些状态单解释一下每个状态****"></a><strong>3、***</strong>*？并简线程有哪些状态单解释一下每个状态****</h3><p>\1. <strong><em>\</em>新建(NEW)**</strong>：新创建了一个线程对象。</p>
<p>\2. <strong><em>\</em>可运行(RUNNABLE)**</strong>：线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</p>
<p>\3. <strong><em>\</em>运行(RUNNING)**</strong>：可运行状态(runnable)的线程获得了cpu 时间片（timeslice） ，执行程序代码。<br>\4. <strong><em>\</em>阻塞(BLOCKED)**</strong>：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。阻塞的情况分三种： </p>
<p>(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)    中。<br>    (二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会    把该线程放入锁池(lock pool)中。<br>    (三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</p>
<p>\5. <strong><em>\</em>死亡(DEAD)**</strong>：线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</p>
<h3 id="4、-java程序中怎么保证多线程的运行安全？"><a href="#4、-java程序中怎么保证多线程的运行安全？" class="headerlink" title="4、****java程序中怎么保证多线程的运行安全？****"></a><strong>4、***</strong>*java程序中怎么保证多线程的运行安全？****</h3><p>线程的安全性问题体现在：</p>
<p>· 原子性：一个或者多个操作在 CPU 执行的过程中不被中断的特性</p>
<p>· 可见性：一个线程对共享变量的修改，另外一个线程能够立刻看到</p>
<p>· 有序性：程序执行的顺序按照代码的先后顺序执行 </p>
<p>导致原因：</p>
<p>· 缓存导致的可见性问题</p>
<p>· 线程切换带来的原子性问题</p>
<p>· 编译优化带来的有序性问题</p>
<p>解决办法：</p>
<p>· JDK Atomic开头的原子类、synchronized、LOCK，可以解决原子性问题</p>
<p>· synchronized、volatile、LOCK，可以解决可见性问题</p>
<p>· Happens-Before 规则可以解决有序性问题</p>
<h3 id="5、-什么是死锁？怎么防止死锁"><a href="#5、-什么是死锁？怎么防止死锁" class="headerlink" title="5、****什么是死锁？怎么防止死锁****"></a><strong>5、***</strong>*什么是死锁？怎么防止死锁****</h3><p>所谓死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象死锁。</p>
<p>当然死锁的产生是必须要满足一些特定条件的：</p>
<p>1.互斥条件：进程对于所分配到的资源具有排它性，即一个资源只能被一个进程占用，直到被该进程释放</p>
<p>2.请求和保持条件：一个进程因请求被占用资源而发生阻塞时，对已获得的资源保持不放。</p>
<p>3.不剥夺条件：任何一个资源在没被该进程释放之前，任何其他进程都无法对他剥夺占用</p>
<p>4.循环等待条件：当发生死锁时，所等待的进程必定会形成一个环路（类似于死循环），造成永久阻塞。</p>
<p><strong><em>\</em>1) 预防死锁。**</strong></p>
<p>　　这是一种较简单和直观的事先预防的方法。方法是通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者几个，来预防发生死锁。预防死锁是一种较易实现的方法，已被广泛使用。但是由于所施加的限制条件往往太严格，可能会导致系统资源利用率和系统吞吐量降低。</p>
<p><strong><em>\</em>2) 避免死锁。**</strong></p>
<p>　　该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。</p>
<h3 id="6、synchronized-、-volatile-、Lock-、ReentrantLock-的区"><a href="#6、synchronized-、-volatile-、Lock-、ReentrantLock-的区" class="headerlink" title="\6、synchronized 、 volatile 、Lock 、ReentrantLock  的区**"></a><strong><em>\</em>6、synchronized 、 volatile 、Lock 、ReentrantLock  的区**</strong></h3><h3 id="别是什么？"><a href="#别是什么？" class="headerlink" title="\别是什么？**"></a><strong><em>\</em>别是什么？**</strong></h3><p>synchronized可作用于一段代码或方法，既可以保证可见性，又能够保证原子性。当两个并发线程访问同一个对象object中的这个加锁同步代码块时，一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块。然而，当一个线程访问object的一个加锁代码块时，另一个线程仍然可以访问该object中的非加锁代码块。</p>
<p>Lock是一个接口，可以实现同步访问。</p>
<p>ReentrantLock,意思是“可重入锁”,是唯一实现了Lock接口的类，并且ReentrantLock提供了更多的方法。</p>
<p>volatile是一个类型修饰符（type specifier）。它是被设计用来修饰被不同线程访问和修改的变量。确保本条指令不会因编译器的优化而省略，且要求每次直接读值。</p>
<p>volatile仅能使用在变量级别,synchronized则可以使用在变量,方法.</p>
<h3 id="7、-动态代理是什么？在spring中有哪些应用？"><a href="#7、-动态代理是什么？在spring中有哪些应用？" class="headerlink" title="\7、******动态代理是什么？在spring中有哪些应用？****"></a><strong><em>\</em>7、*****</strong>*动态代理是什么？在spring中有哪些应用？****</h3><p>动态代理：当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。</p>
<p>Java 中实现动态的方式：<a href="https://blog.csdn.net/meism5/article/details/90744045" target="_blank" rel="noopener">JDK 中的动态代理</a> 和 <a href="https://blog.csdn.net/meism5/article/details/90781518" target="_blank" rel="noopener">Java类库 CGLib</a></p>
<p>应用场景如：</p>
<p>统计每个 api 的请求耗时</p>
<p>统一的日志输出</p>
<p>校验被调用的 api 是否已经登录和权限鉴定</p>
<p>Spring的 AOP 功能模块就是采用动态代理的机制来实现切面编程</p>
<h3 id="8、-什么是-CSRF-攻击，如何避免？"><a href="#8、-什么是-CSRF-攻击，如何避免？" class="headerlink" title="8、****什么是 CSRF 攻击，如何避免？****"></a><strong>8、***</strong>*什么是 CSRF 攻击，如何避免？****</h3><p>CSRF：Cross-Site Request Forgery（中文：跨站请求伪造），可以理解为是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：<strong><em>\</em>简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的**</strong>。</p>
<p>防御手段：</p>
<p>验证请求来源地址；</p>
<p>关键操作添加验证码；</p>
<p>在请求地址添加 token 并验证。</p>
<h3 id="9、-简述-tcp-和-udp的区别？"><a href="#9、-简述-tcp-和-udp的区别？" class="headerlink" title="9、****简述 tcp 和 udp的区别？****"></a><strong>9、***</strong>*简述 tcp 和 udp的区别？****</h3><p>TCP 是面向连接的，UDP 是面向无连接的</p>
<p>UDP程序结构较简单</p>
<p>TCP 是面向字节流的，UDP 是基于数据报的</p>
<p>TCP 保证数据正确性，UDP 可能丢包</p>
<p>TCP 保证数据顺序，UDP 不保证</p>
<p>TCP对系统资源要求高，UDP少。</p>
<h3 id="10、-tcp为什么要三次握手，两次不行吗？为什么？"><a href="#10、-tcp为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="10、****tcp为什么要三次握手，两次不行吗？为什么？****"></a><strong>10、***</strong>*tcp为什么要三次握手，两次不行吗？为什么？****</h3><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤</p>
<p>只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</p>
<p>如</p>
<p>第一次    A -&gt; B : 你好，B。</p>
<p>第二次   A &lt;- B : 收到。你好，A。</p>
<p>这样的两次握手过程， A 向 B 打招呼得到了回应，即 A 向 B 发送数据，B 是可以收到的。</p>
<p>但是 B 向 A 打招呼，A 还没有回应，B 没有收到 A 的反馈，无法确保 A 可以收到 B 发送的数据。</p>
<p>第三次      A -&gt; B : 收到，B。</p>
<p>只有经过第三次握手，才能确保双向都可以接收到对方的发送的 数据。</p>
<h2 id="第六天"><a href="#第六天" class="headerlink" title="\第六天**"></a><strong><em>\</em>第六天**</strong></h2><h3 id="1、-Java中如何实现跨域？"><a href="#1、-Java中如何实现跨域？" class="headerlink" title="1、****Java中如何实现跨域？****"></a><strong>1、***</strong>*Java中如何实现跨域？****</h3><p>使用拦截器，实现javax.servlet.Filter接口</p>
<p>使用注解的形式，配置org.springframework.web.filter.CorsFilter</p>
<h3 id="2、-简单工厂和抽象工厂有什么区别？"><a href="#2、-简单工厂和抽象工厂有什么区别？" class="headerlink" title="2、****简单工厂和抽象工厂有什么区别？****"></a><strong>2、***</strong>*简单工厂和抽象工厂有什么区别？****</h3><p><strong><em>\</em>简单工厂模式*****</strong>*：****</p>
<p>是由一个工厂对象创建产品实例，简单工厂模式的工厂类一般是使用静态方法，通过不同的参数的创建不同的对象实例</p>
<p>可以生产结构中的任意产品，不能增加新的产品</p>
<p><strong><em>\</em>抽象工厂模式*****</strong>*：****</p>
<p>提供一个创建一系列相关或相互依赖对象的接口，而无需制定他们具体的类，生产多个系列产品</p>
<p>生产不同产品族的全部产品，不能新增产品，可以新增产品族</p>
<h3 id="3、-解释一下什么是-aop？什么是IOC？"><a href="#3、-解释一下什么是-aop？什么是IOC？" class="headerlink" title="3、****解释一下什么是 aop？什么是IOC？****"></a><strong>3、***</strong>*解释一下什么是 aop？什么是IOC？****</h3><p><strong><em>\</em>AOP*****</strong>*：****面向切面编程，是面向对象开发的一种补充，它允许开发人员在不改变原来模型的以满足新的需求，例如，开发人员可以在不改变原来业务逻辑模型的基础可以进行动态的增加日志，安全或异常处理功能。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提供程序的可重用性，同时提高了开发的效率。</p>
<p><strong><em>\</em>IOC**</strong>：就是对象之间的依赖关系由容器来创建，对象之间的关系本来是由我们开发者自己创建和维护的，在我们使用Spring框架后，对象之间的关系由容器来创建和维护，将开发者做的事让容器做，这就是控制反转。BeanFactory接口是Spring Ioc容器的核心接口。</p>
<p><strong><em>\</em>DI**</strong>：我们在使用Spring容器的时候，容器通过调用set方法或者是构造器来建立对象之间的依赖关系。</p>
<p>控制反转是目标，依赖注入是我们实现控制反转的一种手段。</p>
<h3 id="4、-spring-常用的注入方式有哪些？"><a href="#4、-spring-常用的注入方式有哪些？" class="headerlink" title="4、****spring 常用的注入方式有哪些？****"></a><strong>4、***</strong>*spring 常用的注入方式有哪些？****</h3><p>构造方法注入，setter注入，基于注解的注入</p>
<h3 id="5、-spring-中的-bean-是线程安全的吗？支持几种-bean-的作用域？"><a href="#5、-spring-中的-bean-是线程安全的吗？支持几种-bean-的作用域？" class="headerlink" title="5、****spring 中的 bean 是线程安全的吗？支持几种 bean 的作用域？****"></a><strong>5、***</strong>*spring 中的 bean 是线程安全的吗？支持几种 bean 的作用域？****</h3><p>Spring容器中的Bean是否线程安全，容器本身并没有提供Bean的线程安全策略，因此可以说Spring容器中的Bean本身不具备线程安全的特性，但是具体还是要结合具体scope的Bean去研究。</p>
<p>1、singleton:单例，默认作用域。</p>
<p>2、prototype:原型，每次创建一个新对象。</p>
<p>3、request:请求，每次Http请求创建一个新对象，适用于WebApplicationContext环境下。</p>
<p>4、session:会话，同一个会话共享一个实例，不同会话使用不用的实例。</p>
<p>5、global-session:全局会话，所有会话共享一个实例。</p>
<p><strong><em>\</em>线程安全这个问题，要从单例与原型Bean分别进行说明。**</strong></p>
<p><strong><em>\</em>原型Bean**</strong></p>
<p>对于原型Bean,每次创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题。</p>
<p><strong><em>\</em>单例Bean**</strong></p>
<p>对于单例Bean,所有线程都共享一个单例实例Bean,因此是存在资源的竞争。</p>
<p>如果单例Bean,是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行查询以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。</p>
<p>对于有状态的bean，Spring官方提供的bean，一般提供了通过ThreadLocal去解决线程安全的方法，比如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等。</p>
<p><strong><em>\</em>注：**</strong> Spring容器本身并没有提供线程安全的策略，因此是否线程安全完全取决于Bean本身的特性。</p>
<p><strong><em>\</em>使用ThreadLocal的好处**</strong></p>
<p>使得多线程场景下，多个线程对这个单例Bean的成员变量并不存在资源的竞争，因为ThreadLocal为每个线程保存线程私有的数据。</p>
<h3 id="6、-什么是spring-的事务隔离？spring-事务实现方式有哪些？"><a href="#6、-什么是spring-的事务隔离？spring-事务实现方式有哪些？" class="headerlink" title="6、****什么是spring 的事务隔离？spring 事务实现方式有哪些？****"></a><strong>6、***</strong>*什么是spring 的事务隔离？spring 事务实现方式有哪些？****</h3><p><strong><em>\</em>DEFAULT**</strong> 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别</p>
<p><strong><em>\</em>READ UNCOMMITTED（读未提交数据）：**</strong>允许事务读取未被其他事务提交的变更数据，会出现脏读、不可重复读和幻读问题。</p>
<p><strong><em>\</em>READ COMMITTED（读已提交数据）：**</strong>只允许事务读取已经被其他事务提交的变更数据，可避免脏读，仍会出现不可重复读和幻读问题。</p>
<p><strong><em>\</em>REPEATABLE READ（可重复读，**</strong>mysql的默认<strong><em>\</em>）：**</strong>确保事务可以多次从一个字段中读取相同的值，在此事务持续期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读，仍会出现幻读问题。</p>
<p><strong><em>\</em>SERIALIZABLE（序列化）：**</strong>确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作，可避免所有并发问题，但性能非常低。</p>
<p>spring实现事务的方式：</p>
<p>   1.编码方式</p>
<p>   2.spring配置方式</p>
<p>   3.注解式</p>
<p>基于AOP技术实现的声明式事务管理，实质就是：在方法执行前后进行拦截，然后再目标方法开始之前创建并加入事务，执行完目标方法后根据执行情况提交或回滚事务.</p>
<p>。</p>
<p>声明式事务管理又有两种实现方式：基于xml配置文件的方式；</p>
<p>另一个是在业务方法上进行@Transaction注解，将事务规则应用到业务逻辑中</p>
<p>一种常见的事务管理配置：事务拦截器TransactionInterceptor和事务自动代理BeanNameAutoProxyCreator相结合的方式</p>
<h3 id="7、-说一下-SpringMVC-运行流程？"><a href="#7、-说一下-SpringMVC-运行流程？" class="headerlink" title="7、****说一下****SpringMVC** **运行流程？****"></a><strong>7、***</strong>*说一下*<strong>**</strong>*SpringMVC*<strong>* *</strong>*运行流程？****</h3><p>客户端请求提交到DispatcherServlet 由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller DispatcherServlet将请求提交到Controller， Controller调用业务逻辑处理后，返回ModelAndView， DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图 视图负责将结果显示到客户</p>
<p>1.用户发送请求至前端控制器DispatcherServlet<br>2.DispatcherServlet收到请求调用处理器映射器HandlerMapping。<br>3.处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。<br>4.DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作<br>5.执行处理器Handler(Controller，也叫页面控制器)。<br>6.Handler执行完成返回ModelAndView<br>7.HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet<br>8.DispatcherServlet将ModelAndView传给ViewReslover视图解析器<br>9.ViewReslover解析后返回具体View<br>10.DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）。<br>11.DispatcherServlet响应用户。</p>
<h3 id="8、-简述-Spring-IoC-的实现机制？"><a href="#8、-简述-Spring-IoC-的实现机制？" class="headerlink" title="8、****简述 Spring IoC 的实现机制？****"></a><strong>8、***</strong>*简述 Spring IoC 的实现机制？****</h3><p>以前的代码控制权在调用方，所以要每当程序要更新修改功能时，一定要大量修改调用方的代码才行，工程量大，维护麻烦。后来有了IOC，可以将所有的功能模块交由配置文件（XML）统一管理，如果要增加或者删除某个功能模块时，只需要通过配置文件增加或删除那个模块的关联就可以了。全程不用修改调用方（用户）的代码，大大减少了程序更新时造成的损失。我们将代码的调用权（用户）从调用方转移给被调用方（服务端）的设计模式称为控制反转（IOC）</p>
<p>要实现 IOC，必须满足下面两个条件：</p>
<p>（1）在程序启动时就要根据配置文件关联的各个模块创建对象，放在Spring容器里面。</p>
<p>（2）调用方（用户）使用一个接口或类的引用（不用 new对象，这也是Spring实现可插拔的关键），就可以创建获得对象。</p>
<p>我们将这种不用 new，而是根据接口或者类的引用就可以从被调用的容器里获得创建的对象的方式称为“依赖注入”。</p>
<p>所以，控制反转（IOC）等于是“依赖注入”加上面向接口的编程思想的实现。</p>
<p>我们可以把IOC容器的工作模式看做是工厂模式的升华，可以把IOC容器看作是一个工厂，这个工厂里要生产的对象都在配置文件中给出定义，然后利用编程语言的的反射编程，根据配置文件中给出的类名生成相应的对象。从实现来看，IOC是把以前在工厂方法里写死的对象生成代码，改变为由配置文件来定义，也就是把工厂和对象生成这两者独立分隔开来，目的就是提高灵活性和可维护性。</p>
<h3 id="9、-Spring-Bean-在容器的生命周期是什么样的？"><a href="#9、-Spring-Bean-在容器的生命周期是什么样的？" class="headerlink" title="9、****Spring Bean 在容器的生命周期是什么样的？****"></a><strong>9、***</strong>*Spring Bean 在容器的生命周期是什么样的？****</h3><p><strong><em>\</em>1.Spring IOC容器可以管理bean的生命周期，Spring允许在bean生命周期内特定的时间点执行指定的任务。**</strong></p>
<p><strong><em>\</em>2.Spring IOC容器对bean的生命周期进行管理的过程：**</strong></p>
<p>① 通过构造器或工厂方法创建bean实例</p>
<p>② 为bean的属性设置值和对其他bean的引用</p>
<p>③ 调用bean的初始化方法</p>
<p>④ bean可以使用了</p>
<p>⑤ 当容器关闭时，调用bean的销毁方法</p>
<p><strong><em>\</em>3.在配置bean时，通过init-method和destroy-method 属性为bean指定初始化和销毁方法**</strong></p>
<p><strong><em>\</em>4.bean的后置处理器**</strong></p>
<p>① bean后置处理器允许在调用初始化方法前后对bean进行额外的处理</p>
<p>② bean后置处理器对IOC容器里的所有bean实例逐一处理，而非单一实例。其典型应用是：检查bean属性的正确性或根据特定的标准更改bean的属性。</p>
<p>③ bean后置处理器时需要实现接口：</p>
<p>org.springframework.beans.factory.config.BeanPostProcessor。在初始化方法被调用前后，Spring将把每个bean实例分别传递给上述接口的以下两个方法：</p>
<p>· postProcessBeforeInitialization(Object, String)</p>
<p>· postProcessAfterInitialization(Object, String)</p>
<p><strong><em>\</em>5.添加bean后置处理器后bean的生命周期**</strong></p>
<p>①通过构造器或工厂方法创建bean实例</p>
<p>②为bean的属性设置值和对其他bean的引用</p>
<p>③将bean实例传递给bean后置处理器的postProcessBeforeInitialization()方法</p>
<p>④调用bean的初始化方法</p>
<p>⑤将bean实例传递给bean后置处理器的postProcessAfterInitialization()方法</p>
<p>⑥bean可以使用了</p>
<p>⑦当容器关闭时调用bean的销毁方法</p>
<h3 id="-1"><a href="#-1" class="headerlink" title></a><img src="file:///C:%5CUsers%5C23349%5CAppData%5CLocal%5CTemp%5Cksohtml1160%5Cwps3.jpg" alt="img"></h3><p><img src="file:///C:%5CUsers%5C23349%5CAppData%5CLocal%5CTemp%5Cksohtml1160%5Cwps4.jpg" alt="img"> </p>
<h3 id="10、-解释什么叫延迟加载？"><a href="#10、-解释什么叫延迟加载？" class="headerlink" title="10、****解释什么叫延迟加载？****"></a><strong>10、***</strong>*解释什么叫延迟加载？****</h3><p>默认情况下，容器启动之后会将所有作用域为单例的bean创建好；但是有的业务场景我们并不需要它提前都创建好；此时，我们可以在bean中设置lzay-init=“true”,这样，当容器启动之后，作用域为单例的bean,就不在创建。</p>
<h2 id="第七天"><a href="#第七天" class="headerlink" title="\第七天**"></a><strong><em>\</em>第七天**</strong></h2><h3 id="1、Spring中AOP-有哪些实现方式？"><a href="#1、Spring中AOP-有哪些实现方式？" class="headerlink" title="\1、Spring中AOP 有哪些实现方式？**"></a><strong><em>\</em>1、Spring中AOP 有哪些实现方式？**</strong></h3><p>AOP常用的实现方式有两种，一种是采用声明的方式来实现（基于XML），一种是采用注解的方式来实现（基于AspectJ）</p>
<p>采用声明的方式实现（在XML文件中配置），大致步骤为：配置文件中配置pointcut, 在java中用编写实际的aspect 类, 针对对切入点进行相关的业务处理。</p>
<p>采用注解来做aop, 主要是将写在spring 配置文件中的连接点写到注解里面。</p>
<h3 id="2、简述一下Spring中的事务的实现方式？"><a href="#2、简述一下Spring中的事务的实现方式？" class="headerlink" title="\2、简述一下Spring中的事务的实现方式？**"></a><strong><em>\</em>2、简述一下Spring中的事务的实现方式？**</strong></h3><p>编程式事务管理：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。</p>
<p>基于 TransactionProxyFactoryBean的声明式事务管理。基于xml配置文件</p>
<p>基于 @Transactional 的声明式事务管理，在业务方法上进行@Transaction注解，将事务规则应用到业务逻辑中</p>
<p>这种方式意味着你可以将事务管理和业务代码分离。</p>
<p>基于 Aspectj AOP 配置（注解）事务</p>
<h3 id="3、动态代理与cglib实现的区别？"><a href="#3、动态代理与cglib实现的区别？" class="headerlink" title="\3、动态代理与cglib实现的区别？**"></a><strong><em>\</em>3、动态代理与cglib实现的区别？**</strong></h3><p>Spirng的AOP的动态代理实现机制有两种，分别是:</p>
<p><strong><em>\</em>1）JDK动态代理：**</strong></p>
<p><strong><em>\</em>具体实现原理：**</strong></p>
<p><strong><em>\</em>1、通过实现InvocationHandlet接口创建自己的调用处理器**</strong></p>
<p><strong><em>\</em>2、通过为Proxy类指定ClassLoader对象和一组interface来创建动态代理**</strong></p>
<p><strong><em>\</em>3、通过反射机制获取动态代理类的构造函数，其唯一参数类型就是调用处理器接口类型**</strong></p>
<p><strong><em>\</em>4、通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数参入**</strong></p>
<p><strong><em>\</em>JDK动态代理是面向接口的代理模式，如果被代理目标没有接口那么Spring也无能为力，**</strong></p>
<p><strong><em>\</em>Spring通过java的反射机制生产被代理接口的新的匿名实现类，重写了其中AOP的增强方法。**</strong></p>
<p><strong><em>\</em>2、CGLib动态代理**</strong></p>
<p><strong><em>\</em>CGLib是一个强大、高性能的Code生产类库，可以实现运行期动态扩展java类，Spring在运行期间通过 CGlib继承要被动态代理的类，重写父类的方法，实现AOP面向切面编程呢。**</strong></p>
<p><strong><em>\</em>两者对比：**</strong></p>
<p>JDK动态代理是面向接口，在创建代理实现类时比CGLib要快，创建代理速度快。</p>
<p>CGLib动态代理是通过字节码底层继承要代理类来实现（如果被代理类被final关键字所修饰，那么抱歉会失败），在创建代理这一块没有JDK动态代理快，但是运行速度比JDK动态代理要快。</p>
<p><strong><em>\</em>使用注意：**</strong></p>
<p>如果要被代理的对象是个实现类，那么Spring会使用JDK动态代理来完成操作（Spirng默认采用JDK动态代理实现机制）</p>
<p>如果要被代理的对象不是个实现类那么，Spring会强制使用CGLib来实现动态代理。</p>
<p><strong><em>\</em>选择的使用代理机制**</strong></p>
<p><img src="file:///C:%5CUsers%5C23349%5CAppData%5CLocal%5CTemp%5Cksohtml1160%5Cwps5.jpg" alt="img"> </p>
<p>通过配置Spring的中<a href="aop:config">aop:config</a>标签来显示的指定使用动态代理机制 proxy-target-class=true表示使用CGLib代理，如果为false就是默认使用JDK</p>
<h3 id="4、-Spring-Framework-有哪些不同的功能？"><a href="#4、-Spring-Framework-有哪些不同的功能？" class="headerlink" title="4、****Spring Framework 有哪些不同的功能？****"></a><strong>4、***</strong>*Spring Framework 有哪些不同的功能？****</h3><p><strong>l</strong> <strong><em>\</em>轻量级**</strong>：Spring在大小和透明性方面绝对属于轻量级的，基础版本的Spring框架大约只有2MB。</p>
<p><strong>l</strong> <strong><em>\</em>控制反转(IOC)**</strong>：Spring使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。</p>
<p><strong>l</strong> <strong><em>\</em>面向切面编程(AOP)**</strong>：Spring支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。</p>
<p><strong>l</strong> <strong><em>\</em>容器：**</strong>Spring包含并管理应用程序对象的配置及生命周期。</p>
<p><strong>l</strong> <strong><em>\</em>MVC框架：**</strong>Spring的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。</p>
<p><strong>l</strong> <strong><em>\</em>事务管理**</strong>：Spring对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口。</p>
<p><strong>l</strong> <strong><em>\</em>异常处理：**</strong>Spring提供一个方便的API将特定技术的异常(由JDBC, Hibernate, 或JDO抛出)转化为一致的、Unchecked异常。</p>
<h3 id="5、-spring-提供了哪些配置方式？"><a href="#5、-spring-提供了哪些配置方式？" class="headerlink" title="5、****spring 提供了哪些配置方式？****"></a><strong>5、***</strong>*spring 提供了哪些配置方式？****</h3><p>l 基于 xml 配置</p>
<pre><code>bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包        含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。</code></pre><p>l 基于注解配置</p>
<p>您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，    而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。    因此，您需要在使用它之前在 Spring 配置文件中启用它。</p>
<p>l 基于 Java API 配置</p>
<pre><code>Spring 的 Java 配置是通过使用@Bean 和 @Configuration 来实现。</code></pre><h3 id="6、-说下对IOC容器的理解以及IOC容器是怎么工作的？"><a href="#6、-说下对IOC容器的理解以及IOC容器是怎么工作的？" class="headerlink" title="6、****说下对IOC容器的理解以及IOC容器是怎么工作的？****"></a><strong>6、***</strong>*说下对IOC容器的理解以及IOC容器是怎么工作的？****</h3><p>IOC容器就是具有依赖注入功能的容器，IOC容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。被实例化的对象对依赖创建的控制权从自身转移到容器。应用程序无需直接在代码中new相关的对象，应用程序由IOC容器进行组装。在Spring中BeanFactory是IOC容器的实际代表者。</p>
<p>Spring IOC 容器的工作流程大致分为两个阶段:</p>
<p><strong><em>\</em>阶段1：容器启动**</strong></p>
<p>容器在这阶段的主要工作是收集bean信息，也会进行一些验证性和辅助性的工作。容器要加载Configuration Meta信息，除了纯java代码实现配置的情况，其他方式如通过XML文件的读取，需要借助BeanDefinitionReader组件进行解析。BeanDefinitionReader读取和分析Configuration Meta信息后，组装信息为bean对应的BeanDefinition，并把它注册到BeanDefinitonRegistry中，就完成了容器启动。</p>
<p><strong><em>\</em>阶段2：实例加载**</strong></p>
<p>经过阶段1后，当某个请求通过容器的getBean方法请求某个对象，或者因为依赖关系容器需要隐式的调用getBean时，就会触发阶段2的工作：容器会首先检查所请求的对象之前是否已经实例化完成。如果没有，则会根据注册的BeanDefinition所提供的信息实例化被请求对象，并为其注入依赖。当该对象装配完毕后，容器会立即将其返回给请求方法使用。</p>
<p><strong><em>\</em>3*****</strong>*、*<strong>* *</strong>*BeanFactory和ApplicationContext****</p>
<p>BeanFactory可以管理任何对象，它是Spring IOC容器一种简单的实现，提供了最基本的依赖注入（DI）支持。而在实际场景下，我们更多的使用另外一种类型的容器：ApplicationContext，它集成自BeanFactory，除了基本DI功能，还提供了更高级的功能，如事件监听。</p>
<p>两者bean实例加载策略有区别：BeanFactory默认是延迟加载策略，即只有当访问容器中的某个对象时，才对该对象进行实例化和依赖注入操作；ApplicationContext则模式在容器启动时就全部完成实例化和依赖注入操作。</p>
<p>容器中的每一个bean都会有一个对应的<strong><em>\</em>BeanDefinition**</strong>实例，该实例负责保存bean对象的所有必要信息，包括bean对象的class类型、是否是抽象类、构造方法和参数、其它属性等等。当客户端向容器请求相应对象时，容器就会通过这些信息准备一个完整可用的bean实例返回给客户端。</p>
<p><strong><em>\</em>BeanDefinitionRegistry**</strong>抽象了bean的注册逻辑，包含registerBeanDefinition()、removeBeanDefinition()、getBeanDefinition()等注册管理BeanDefinition的方法。</p>
<p><strong><em>\</em>BeanFactory**</strong>抽象了bean的管理逻辑，包含getBean、containBean、getType、getAliases等管理bean的方法。</p>
<p><strong><em>\</em>总结**</strong></p>
<p>容器的实现可以是简单的BeanFactory或更高级的ApplicationContext。它们借助BeanDefiniton组件实现对bean及依赖信息的管理, 容器启动时收集所有bean的信息。当实例化bean的时候，容器负责将其依赖对象也进行实例化以供使用，这个过程就是依赖注入。</p>
<h3 id="7、-BeanFactory和ApplicationContext的区别是什么？"><a href="#7、-BeanFactory和ApplicationContext的区别是什么？" class="headerlink" title="7、****BeanFactory和ApplicationContext的区别是什么？****"></a><strong>7、***</strong>*BeanFactory和ApplicationContext的区别是什么？****</h3><p>ApplicationContext是BeanFactory的子接口。</p>
<p>l BeanFactroy采用的是延迟加载形式来注入Bean的，在使用到某个Bean时才对该Bean进行加载实例化，这样我们不能发现一些存在的Spring的配置问题。而ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean，这样在容器启动时我们就可以发现Spring中存在的配置错误。 </p>
<p>l BeanFacotry延迟加载,如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常；而ApplicationContext则在初始化自身是检验，这样有利于检查所依赖属性是否注入。</p>
<p>l BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。</p>
<p>l beanFactory主要是面对与 spring 框架的基础设施，面对 spring 自己。而 Applicationcontex 主要面对与 spring 使用的开发者。基本都会使用 Applicationcontex 并非 beanFactory 。</p>
<h3 id="8、-Spring-Aop和AspecJ-Aop有什么区别？"><a href="#8、-Spring-Aop和AspecJ-Aop有什么区别？" class="headerlink" title="\8、******Spring Aop和AspecJ Aop有什么区别？****"></a><strong><em>\</em>8、*****</strong>*Spring Aop和AspecJ Aop有什么区别？****</h3><table>
<thead>
<tr>
<th><strong><em>\</em>Spring AOP**</strong></th>
<th><strong><em>\</em>AspectJ**</strong></th>
</tr>
</thead>
<tbody><tr>
<td>在纯 Java 中实现</td>
<td>使用 Java 编程语言的扩展实现</td>
</tr>
<tr>
<td>不需要单独的编译过程</td>
<td>除非设置 LTW，否则需要 AspectJ 编译器 (ajc)</td>
</tr>
<tr>
<td>只能使用运行时织入</td>
<td>运行时织入不可用。支持编译时、编译后和加载时织入</td>
</tr>
<tr>
<td>功能不强-仅支持方法级编织</td>
<td>更强大 - 可以编织字段、方法、构造函数、静态初始值设定项、最终类/方法等……。</td>
</tr>
<tr>
<td>只能在由 Spring 容器管理的 bean 上实现</td>
<td>可以在所有域对象上实现</td>
</tr>
<tr>
<td>仅支持方法执行切入点</td>
<td>支持所有切入点</td>
</tr>
<tr>
<td>代理是由目标对象创建的, 并且切面应用在这些代理上</td>
<td>在执行应用程序之前 (在运行时) 前, 各方面直接在代码中进行织入</td>
</tr>
<tr>
<td>比 AspectJ 慢多了</td>
<td>更好的性能</td>
</tr>
<tr>
<td>易于学习和应用</td>
<td>相对于 Spring AOP 来说更复杂</td>
</tr>
</tbody></table>
<h3 id="9、-Spring中的bean都有哪些作用域？"><a href="#9、-Spring中的bean都有哪些作用域？" class="headerlink" title="\9、******Spring中的bean都有哪些作用域？****"></a><strong><em>\</em>9、*****</strong>*Spring中的bean都有哪些作用域？****</h3><p>l singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例</p>
<p>l prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例</p>
<p>l request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效</p>
<p>l session：对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效</p>
<p>l globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效</p>
<p>　　其中比较常用的是singleton和prototype两种作用域。对于singleton作用域的Bean，每次请求该Bean都将获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为；如果一个Bean被设置成prototype作用域，程序每次请求该id的Bean，Spring都会新建一个Bean实例，然后返回给程序。在这种情况下，Spring容器仅仅使用new 关键字创建Bean实例，一旦创建成功，容器不在跟踪实例，也不会维护Bean实例的状态。</p>
<p>　　如果不指定Bean的作用域，Spring默认使用singleton作用域。Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。</p>
<h3 id="10、-简述一下Spring中的单例Bean的线程安全问题？"><a href="#10、-简述一下Spring中的单例Bean的线程安全问题？" class="headerlink" title="10、****简述一下Spring中的单例Bean的线程安全问题？****"></a><strong>10、***</strong>*简述一下Spring中的单例Bean的线程安全问题？****</h3><p>默认 spring 容器中的 bean 是单例的，当单例中存在竞态条件，即有线程安全问题，所以 spring 管理的 bean 的线程安全跟 bean 的创建作用域和 bean 所在的使用环境是否存在竞态条件有关，spring 并不能保证 bean 的线程安全。</p>
<h2 id="第八天"><a href="#第八天" class="headerlink" title="\第八天**"></a><strong><em>\</em>第八天**</strong></h2><h3 id="1、-你使用过Spring的事务吗？是怎么用的？"><a href="#1、-你使用过Spring的事务吗？是怎么用的？" class="headerlink" title="1、****你使用过Spring的事务吗？是怎么用的？****"></a><strong>1、***</strong>*你使用过Spring的事务吗？是怎么用的？****</h3><p>使用过基于注解和基于xml配置的事务管理，注解是在业务方法上使用@Transaction注解，将事务规则应用到业务逻辑中。基于xml配置是在applicationContext.xml进行配置就可以了</p>
<h3 id="2、Spring的事务有哪几种隔离级别"><a href="#2、Spring的事务有哪几种隔离级别" class="headerlink" title="\2、Spring的事务有哪几种隔离级别?**"></a><strong><em>\</em>2、Spring的事务有哪几种隔离级别?**</strong></h3><p>DEFAULT这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别；<br>未提交读（read uncommited）：脏读，不可重复读，虚读都有可能发生<br>已提交读（read commited）：避免脏读。但是不可重复读和虚读都有可能发生；<br>可重复读（repeatable read）：避免脏读和不可重复读，但是虚读有可能发生；<br>串行化的（serializable）：避免以上所有读问题。<br>MySQL默认：可重复读<br>Oracle默认：已提交读</p>
<img src="file:///C:\Users\23349\AppData\Local\Temp\ksohtml1160\wps6.jpg" alt="img"> 



<p>read uncommitted：是最低读事务隔离级别，它允许另外一个事务可以看到这个事务未提交读数据。<br>read commited： 保证一个事务提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。<br>repeatable read：这种事务隔离级别可以防止脏读，不可重复读。但是可能会出现幻想读。它除了保证一个事务不能被另外一个事务读取未提交读数据之外还避免了一下情况产生（不可重复读）。<br>serializable：这是花费最高代价但最可靠但事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读之外，还避免了幻象读（避免三种）。</p>
<p><strong><em>\</em>脏读（Dirty read）**</strong>– 脏读发生在一个事务读取了被另一个事务改写但尚未提交的数据时。如果这些改变在稍后被回滚了，那么第一个事务读取的数据就会是无效的。</p>
<p><strong><em>\</em>不可重复读（Nonrepeatable read）**</strong>– 不可重复读发生在一个事务执行相同的查询两次或两次以上，但每次查询结果都不相同时。这通常是由于另一个并发事务在两次查询之间更新了数据。</p>
<p><strong><em>\</em>幻影读（Phantom reads）**</strong>– 幻影读和不可重复读相似。当一个事务（T1）读取几行记录后，另一个并发事务（T2）插入了一些记录时，幻影读就发生了。在后来的查询中，第一个事务（T1）就会发现一些原来没有的额外记录。</p>
<h3 id="3、-Spring事务有哪几种事务传播行为？"><a href="#3、-Spring事务有哪几种事务传播行为？" class="headerlink" title="\3、******Spring事务有哪几种事务传播行为？****"></a><strong><em>\</em>3、*****</strong>*Spring事务有哪几种事务传播行为？****</h3><p>1.PROPAGATION_REQUIRED – 支持当前事务，如果当前没有事务，就新建一个事务。（默认）</p>
<p>2.PROPAGATION_SUPPORTS – 支持当前事务，如果当前没有事务，就以非事务方式执行。</p>
<p>3.PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。</p>
<p>4.PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。</p>
<p>5.PROPAGATION_NOT_SUPPORTED – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p>
<p>6.PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。</p>
<p>7.PROPAGATION_NESTED – 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</p>
<p><strong><em>\</em>备注：**</strong>常用的两个事务传播属性是1和4，即PROPAGATION_REQUIRED，PROPAGATION_REQUIRES_NEW</p>
<h3 id="4、-spring-JDBC-API-中存在哪些类？"><a href="#4、-spring-JDBC-API-中存在哪些类？" class="headerlink" title="4、****spring JDBC API 中存在哪些类？****"></a><strong>4、***</strong>*spring JDBC API 中存在哪些类？****</h3><p>JDBC定义了很多接口和类，主要把包括DriverManager、Connection、Statement、PreparedStatement和ResultSet等。</p>
<p>1、DriverManager是JDBC管理层，作用于用户和驱动程序之间。它跟踪可用的驱动程序，并在数据库和响应的驱动程序之间建立连接。该类负责加载、注册JDBC驱动程序，管理应用程序和已注册的驱动 程序的连接</p>
<p>2、Connection接口代表与数据库的连接，并拥有创建SQL语句的方法，用来完成基本的SQL操作</p>
<p>3、Statement接口，主要是进行部分增删改查操作</p>
<p>4、ResultSet接口，在执行查询语句后，会返回一个ResultSet查询结果集，ResultSet提供了逐行访问这些记录的方法</p>
<p><img src="file:///C:%5CUsers%5C23349%5CAppData%5CLocal%5CTemp%5Cksohtml1160%5Cwps7.jpg" alt="img"> </p>
<h3 id="5、-简单的说一下spring的生命周期？"><a href="#5、-简单的说一下spring的生命周期？" class="headerlink" title="5、****简单的说一下spring的生命周期？****"></a><strong>5、***</strong>*简单的说一下spring的生命周期？****</h3><p>\1. instantiate bean对象实例化</p>
<p>\2. populate properties 封装属性</p>
<p>\3. 如果Bean实现BeanNameAware执行setBeanName</p>
<p>\4. 如果Bean实现BeanFactoryAwar或ApplicationContextAwar设置工厂setBeanFactory或上下文对象setApplicationContext</p>
<p>\5. 如果存在类实现BeanPostProcessor(后处理Bean),执行postProcessBeforeInitialization</p>
<p>\6. 如果Bean实现InitializingBean执行afterPropertiesSet</p>
<p>\7. 调用自定义的init-method方法</p>
<p>\8. 如果存在类实现BeanPostProcessor(处理Bean),执行postProcessAfterInitialization</p>
<p>\9. 执行业务处理</p>
<p>\10. 如果Bean实现DisposableBean执行destroy</p>
<p>\11. 调用自定义的destroy-method</p>
<p>　　<strong><em>\</em>第一步**</strong>就是对实例化bean，调用构造函数来创建实例，<strong><em>\</em>第二步**</strong>是根据配置，进行相应属性的设置，依赖注入就是在这一步完成的。</p>
<p>　　<strong><em>\</em>第三步和第四步**</strong>是让spring去了解咱们的spring容器，<strong><em>\</em>第五步和第八步**</strong>可以针对指定的Bean进行功能增强，这时一般是采用的动态代理，（两种动态代理方式：jdk动态代理和cglib动态代理）。<strong><em>\</em>第六步和第十步**</strong>是通过实现指定的接口来完成init（初始化）和destory（销毁）操作。但是我们在通常情况下不会使用这两步，因为我们可以通过<strong><em>\</em>第七步和第十一步**</strong>，在配置文件中设置相应的初始化和销毁方法。</p>
<p>　　比如：</p>
<p><img src="file:///C:%5CUsers%5C23349%5CAppData%5CLocal%5CTemp%5Cksohtml1160%5Cwps8.jpg" alt="img"> </p>
<p>　　总结：</p>
<p>　　　　对于springbean的生命周期，我们需要关注的主要有两个方法：</p>
<p>　　　　　　1.增强bean的功能可以使用后处理Bean，BeanPostProcessor</p>
<p>　　　　　    2.如果需要初始化或销毁操作，我们可以使用init-method方法和destory-method方法。</p>
<p>　　同时还需要注意一点：destory-method方法是只针对于scope=singleton的时候才有效果！</p>
<h3 id="6、-Spring如何处理线程并发问题？"><a href="#6、-Spring如何处理线程并发问题？" class="headerlink" title="6、****Spring如何处理线程并发问题？****"></a><strong>6、***</strong>*Spring如何处理线程并发问题？****</h3><p><strong><em>\</em>Spring使用ThreadLocal解决线程安全问题**</strong></p>
<p>我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean(如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等)中非线程安全状态采用ThreadLocal进行处理，让它们也成为线程安全的状态，因为有状态的Bean就可以在多线程中共享了。</p>
<p>ThreadLocal和线程同步机制都是为了解决多线程中相同变量的访问冲突问题。</p>
<p>在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。</p>
<p>而ThreadLocal则从另一个角度来解决多线程的并发访问。ThreadLocal会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进ThreadLocal。</p>
<p>由于ThreadLocal中可以持有任何类型的对象，低版本JDK所提供的get()返回的是Object对象，需要强制类型转换。但JDK5.0通过泛型很好的解决了这个问题，在一定程度地简化ThreadLocal的使用。</p>
<p>概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p>
<h3 id="7、-解释一下Spring-AOP里面的几个名词？"><a href="#7、-解释一下Spring-AOP里面的几个名词？" class="headerlink" title="7、****解释一下Spring AOP里面的几个名词？****"></a><strong>7、***</strong>*解释一下Spring AOP里面的几个名词？****</h3><p>（1）切面（Aspect）：被抽取的公共模块，可能会横切多个对象。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。</p>
<p>（2）连接点（Join point）：指方法，在Spring AOP中，一个连接点 总是 代表一个方法的执行。</p>
<p>（3）通知（Advice）：在切面的某个特定的连接点（Join point）上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等通知。许多AOP框架，包括Spring，都是以拦截器做通知模型， 并维护一个以连接点为中心的拦截器链。</p>
<p>（4）切入点（Pointcut）：切入点是指 我们要对哪些Join point进行拦截的定义。通过切入点表达式，指定拦截的方法，比如指定拦截add<strong>、search</strong>。</p>
<p>（5）引入（Introduction）：（也被称为内部类型声明（inter-type declaration））。声明额外的方法或者某个类型的字段。Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。</p>
<p>（6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。也有人把它叫做 被通知（adviced） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</p>
<p>（7）织入（Weaving）：指把增强应用到目标对象来创建新的代理对象的过程。Spring是在运行时完成织入。</p>
<h3 id="8、-解释spring中不同方式的自动装配"><a href="#8、-解释spring中不同方式的自动装配" class="headerlink" title="8、****解释spring中不同方式的自动装配****"></a><strong>8、***</strong>*解释spring中不同方式的自动装配****</h3><p><strong><em>\</em>no**</strong>：默认的方式是不进行自动装配，通过显式设置ref 属性来进行装配。我们可以在xml中，设置beans标签的default-autowire属性为byName，byType等，来设置所有bean都进行自动装配。</p>
<p><strong><em>\</em>byName：**</strong>通过参数名 自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byname，之后容器试图匹配、装配和该bean的属性具有相同名字的bean。</p>
<p><strong><em>\</em>byType:：**</strong>通过参数类型自动装配，Spring容器在配置文件中发现bean的autowire属性被设置成byType，之后容器试图匹配、装配和该bean的属性具有相同类型的bean。如果有多个bean符合条件，则抛出错误。</p>
<p><strong><em>\</em>constructor：这个方式类似于**</strong>byType， 但是要提供给构造器参数，如果没有确定的带参数的构造器参数类型，将会抛出异常。</p>
<p><strong><em>\</em>autodetect：**</strong>首先尝试使用constructor来自动装配，如果无法工作，则使用byType方式。</p>
<h3 id="9、-ApplicationContext通常的实现是什么？"><a href="#9、-ApplicationContext通常的实现是什么？" class="headerlink" title="9、****ApplicationContext通常的实现是什么？****"></a><strong>9、***</strong>*ApplicationContext通常的实现是什么？****</h3><p>1&gt;FileSystemXmlApplicationContext:此容器从一个XML文件中加载bean的定义，XML Bean配置文件的全路径名必须提供给它的构造函数</p>
<p>2&gt;ClassPathXmlApplicationContext:此容器也从一个XML文件中加载bean的定义，这里需要正确设置classpath因为这个容器将在classpath里找bean配置</p>
<p>3&gt;WebXmlApplicationContext:此容器加载一个XML文件，此文件定义了一个WEB应用的所有bean</p>
<h3 id="10、什么是基于Java的Spring注解配置-给一些常见注解的例子"><a href="#10、什么是基于Java的Spring注解配置-给一些常见注解的例子" class="headerlink" title="\10、什么是基于Java的Spring注解配置? 给一些常见注解的例子**"></a><strong><em>\</em>10、什么是基于Java的Spring注解配置? 给一些常见注解的例子**</strong></h3><p>理解：</p>
<p>1、使用Spring的时候可以使用XML文件配置，也可以使用Java代码配置。使用Java代码配置的时候，相当于使用Java类作为XML的配置文件，通过使用java代码创建bean实例，并通过java代码完成依赖的注入操作。当需要变更依赖注入时，可通过修改java代码实现。</p>
<p>2、使用注解配置的时候，个人理解存在两种方式第一种是注解+XML形式，第二种是Java代码+注解形式。使用Java+注解的形式，相当于在Java代码中指定组件扫描，在具体的bean中使用注解标识。</p>
<p><strong><em>\</em>Java注解配置是*****</strong>*Spring*<strong>**</strong>*4.*<strong>**</strong>*x推荐的配置方式，可以完全替代*<strong>**</strong>*xml*<strong>**</strong>*配置。Spring的*<strong>**</strong>*Java注解*<strong>**</strong>*配置方式是通过*<strong>* *</strong>*@Configuration*<strong>* *</strong>*和*<strong>* *</strong>*@Bean*<strong>* *</strong>*这两个注解实现的：****</p>
<p> 1、@Configuration 作用于类上，相当于一个xml配置文件；</p>
<p> 2、@Bean 作用于方法上，相当于xml配置中的<bean>；</bean></p>
<p><strong><em>\</em>读取外部的资源配置文件**</strong>,通过@PropertySource可以指定读取的配置文件，通过@Value注解获取值，具体用法：</p>
<p>/*</p>
<p> 1.使用Java配置时，配置文件使用@Configuration修饰，在Java代码中使用@Bean修饰</p>
<p> 2.在获取bean时，通过AnnotationConfigApplicationContext获取</p>
<p> 3.如果需要结合注解配置时，则使用@ComponentScan注解开启扫描</p>
<p> 4.常用的注解有以下几类</p>
<p>*/</p>
<p>@Controller</p>
<p>@Bean</p>
<p>@Service</p>
<p>@Component</p>
<p>@Repository</p>
<p>@Autowired</p>
<h2 id="第九天"><a href="#第九天" class="headerlink" title="\第九天**"></a><strong><em>\</em>第九天**</strong></h2><h3 id="1、-和-的区别是什么？"><a href="#1、-和-的区别是什么？" class="headerlink" title="1、****#{} 和 ${} 的区别是什么？****"></a><strong>1、***</strong>*#{} 和 ${} 的区别是什么？****</h3><p>1）#{}是预编译处理，$ {}是字符串替换。</p>
<p>2）mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；mybatis在处理 $ { } 时，就是把 ${ } 替换成变量的值。</p>
<p>3）使用 #{} 可以有效的防止SQL注入，提高系统安全性。</p>
<p>要理解记忆这个题目,我觉得要抓住两点：</p>
<p>（1）$ 符号一般用来当作占位符，常使用Linux脚本的同学应该对此有更深的体会吧。既然是占位符，当然就是被用来替换的。知道了这点就能很容易区分$和#，从而不容易记错了。</p>
<p>（2）预编译的机制。预编译是提前对SQL语句进行预编译，而其后注入的参数将不会再进行SQL编译。我们知道，SQL注入是发生在编译的过程中，因为恶意注入了某些特殊字符，最后被编译成了恶意的执行操作。而预编译机制则可以很好的防止SQL注入。在某些特殊场合下只能用${}，不能用#{}。例如：在使用排序时ORDER BY ${id}，如果使用#{id}，则会被解析成ORDER BY “id”,这显然是一种错误的写法。</p>
<h3 id="2、-当实体类中的属性名和表中的字段名不一样时有哪些处理方法？"><a href="#2、-当实体类中的属性名和表中的字段名不一样时有哪些处理方法？" class="headerlink" title="2、****当实体类中的属性名和表中的字段名不一样时有哪些处理方法？****"></a><strong>2、***</strong>*当实体类中的属性名和表中的字段名不一样时有哪些处理方法？****</h3><p>l 通过在查询的 sql 语句中定义字段名的别名，让字段名的别名和实体类</p>
<p>l 通过<resultMap>来映射字段名和实体类属性名的一一对应的关系。</resultMap></p>
<h3 id="3、-Mybatis-动态-SQL-是做什么的？都有哪些动态-SQL-？能简述一下动态-SQL-的执行原理吗？"><a href="#3、-Mybatis-动态-SQL-是做什么的？都有哪些动态-SQL-？能简述一下动态-SQL-的执行原理吗？" class="headerlink" title="3、****Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？****"></a><strong>3、***</strong>*Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？****</h3><p> Mybatis 动态 SQL ，可以让我们在 XML 映射文件内，以 XML 标签的形 式编写动态 SQL ，完成逻辑判断和动态拼接 SQL 的功能。</p>
<p> Mybatis 提供了 9 种动态 SQL 标签：<if>、<choose>、<when>、<otherwise>、<trim>、<when>、<set>、<foreach>、<bind>。</bind></foreach></set></when></trim></otherwise></when></choose></if></p>
<p>其执行原理为，使用 OGNL 的表达式，从 SQL 参数对象中计算表达式的值,根据表达式的值动态拼接 SQL ，以此来完成动态 SQL 的功能。</p>
<h3 id="4、-通常一个-XML-映射文件，都会写一个-Mapper-接口与之对应。请问，这个-Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？"><a href="#4、-通常一个-XML-映射文件，都会写一个-Mapper-接口与之对应。请问，这个-Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="4、****通常一个 XML 映射文件，都会写一个 Mapper 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？****"></a><strong>4、***</strong>*通常一个 XML 映射文件，都会写一个 Mapper 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？****</h3><p>Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。</p>
<p>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement</p>
<p>在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。</delete></update></insert></select></p>
<p>Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p>
<p>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p>
<h3 id="5、-Mapper接口绑定有几种实现方式-分别是怎么实现的"><a href="#5、-Mapper接口绑定有几种实现方式-分别是怎么实现的" class="headerlink" title="5、****Mapper接口绑定有几种实现方式,分别是怎么实现的?****"></a><strong>5、***</strong>*Mapper接口绑定有几种实现方式,分别是怎么实现的?****</h3><p>l 第一种，通过 XML Mapper 里面写 SQL 来绑定。在这种情况下，要指定 XML 映射文件里面的 “namespace” 必须为接口的全路径名。</p>
<p>l 第二种，通过注解绑定，就是在接口的方法上面加上 @Select、@Update、 @Insert、@Delete 注解，里面包含 SQL 语句来绑定。</p>
<p>l 第三种，是第二种的特例，也是通过注解绑定，在接口的方法上面加 上 @SelectProvider、@UpdateProvider、@InsertProvider、@DeleteProvider 注解，通过 Java 代码，生成对应的动态 SQL 。</p>
<h3 id="6、-在mybatis中如何获取自动生成的-主-键值"><a href="#6、-在mybatis中如何获取自动生成的-主-键值" class="headerlink" title="6、****在mybatis中如何获取自动生成的(主)键值?****"></a><strong>6、***</strong>*在mybatis中如何获取自动生成的(主)键值?****</h3><p>在insert标签中加入属性useGeneratedKeys=”true” 和 keyProperty=”id”</p>
<p>这里需要注意的是需要把实体类传进来。keyProperty为自增的id字段。调用insert后自动将自增id赋值进insert调用的实体类中</p>
<p>getId()就可以获取到自增id</p>
<h3 id="7、-在-Mapper-中如何传递多个参数"><a href="#7、-在-Mapper-中如何传递多个参数" class="headerlink" title="7、****在 Mapper 中如何传递多个参数?****"></a><strong>7、***</strong>*在 Mapper 中如何传递多个参数?****</h3><p>第1种：使用占位符的思想</p>
<p>在映射文件中使用#{0}，#{1}代表传递进来的第几个参数。<br>使用@param注解:来命名参数</p>
<p>第2种：使用Map集合作为参数来装载</p>
<p>根据key自动找到对应Map集合的value</p>
<h3 id="8、-Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#8、-Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="8、****Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？****"></a><strong>8、***</strong>*Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？****</h3><p>Mybatis有三种基本的Executor执行器，<strong><em>\</em>SimpleExecutor、ReuseExecutor、BatchExecutor**</strong>。</p>
<p>· SimpleExecutor：每执行一次update或select，就开启一个Statement对象，<strong><em>\</em>用完立刻关闭Statement对象**</strong>。</p>
<p>· ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，<strong><em>\</em>就是重复使用Statement对象**</strong>。</p>
<p>· BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），<strong><em>\</em>它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同**</strong>。</p>
<p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p>
<p>Mybatis中如何指定使用哪种处理器：</p>
<p>(1)配置文件中<setting name="defaultExecutorType" value="REUSE"></setting></p>
<p>(2)手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数</p>
<h3 id="9、-MyBatis-执行批量插入有哪些方式？-优缺点是什么"><a href="#9、-MyBatis-执行批量插入有哪些方式？-优缺点是什么" class="headerlink" title="9、****MyBatis 执行批量插入有哪些方式？ 优缺点是什么?****"></a><strong>9、***</strong>*MyBatis 执行批量插入有哪些方式？ 优缺点是什么?****</h3><p>方法一：xml配置</p>
<p>最基础的是用xml配置的方式，包括以下两种具体方式：</p>
<p>\1. xml中insert语句可以写成单条插入，再调用方循环</p>
<p>\2. Xml中传入list，使用foreach标签循环list</p>
<p>方法二：</p>
<p>MyBatis提供用于插入数据的注解有两个：@insert，@InsertProvider</p>
<p>@Insert是直接配置SQL语句，而@InsertProvider则是通过SQL工厂类及对应的方法生产SQL语句，这种方法的好处在于，我们可以根据不同的需求生产出不同的SQL，适用性更好。</p>
<p><img src="file:///C:%5CUsers%5C23349%5CAppData%5CLocal%5CTemp%5Cksohtml1160%5Cwps9.jpg" alt="img"> </p>
<p>type为工厂类的类对象，</p>
<p>method为对应的工厂类中的方法，方法中的@Param（“list”）是因为批量插入传入的是一个list，但是Mybatis会将其包装成一个map，其中map的key为“list”，value为传入的list</p>
<p><img src="file:///C:%5CUsers%5C23349%5CAppData%5CLocal%5CTemp%5Cksohtml1160%5Cwps10.jpg" alt="img"> </p>
<p>首先要map.get方法得到对应的list；</p>
<p>然后拼接insert语句,要生成的正确的sql语句的格式为：</p>
<p>INSERT INTO User (id,name) VALUES (null,#{list[0].name}),(null, #{list[1].name})[,(null, #{list[i].name})] </p>
<p>其中list[0]代表list中第0个元素</p>
<p><strong><em>\</em>特别注意：**</strong></p>
<p>一定注意：注意Mapper到Provider参数类型的变化（List –&gt; Map），Mapper中传入的List会被包裹在一个Map中传给Provider，而key就是在Mapper的@Param注解中指定的名称（默认为list）。在Provider方法中使用List<T> list = (List<T>) map.get(key);即可拿到我们传入的List。</T></T></p>
<p>否则会报错：</p>
<p><strong><em>\</em>xml、注解方式区别：**</strong></p>
<p>1.foreach相当语句逐条INSERT语句执行，将出现如下问题：</p>
<p>l mapper接口的isnert方法返回值将是最一条INSERT语句的操作成功的记录数目（就是0或1），而不是所有INSERT语句的操作成功的总记录数目</p>
<p>l 当其中一条不成功时，不会进行整体回滚。</p>
<p>2.注解方式：当有一条插入不成功时，会整体回滚</p>
<h3 id="10、介绍-MyBatis-的一级缓存和二级缓存的概念和实现原理？"><a href="#10、介绍-MyBatis-的一级缓存和二级缓存的概念和实现原理？" class="headerlink" title="\10、介绍 MyBatis 的一级缓存和二级缓存的概念和实现原理？**"></a><strong><em>\</em>10、介绍 MyBatis 的一级缓存和二级缓存的概念和实现原理？**</strong></h3><p><strong>1.</strong> <strong><em>\</em>一级缓存**</strong>的粒度较小，是与某个SqlSession绑定的，<strong><em>\</em>只对该SqlSession的相关查询操作进行缓存，**</strong>不同SqlSession实例之间相互不影响，缓存为使用本地内存实现；</p>
<p><strong>2.</strong> <strong><em>\</em>二级缓存是一种全局缓存，是由所有SqlSession实例所共享的，**</strong>即不同SqlSession实例查询时产生的缓存，对其他SqlSession实例可见。</p>
<p><strong><em>\</em>一级缓存**</strong></p>
<p>mybatis的一级缓存支持两种缓存级别，分别是SESSION和STATEMENT，默认的一级缓存级别为SESSION。</p>
<p><strong><em>\</em>mybatis的一级缓存是默认开启的。**</strong></p>
<p><strong><em>\</em>SESSION级别**</strong></p>
<p>l 对该SqlSession实例发起的查询操作进行缓存，即由同一SqlSession实例发起的多次相同（SQL和SQL的参数值都相同）的查询操作，第一次是查询数据库，后续则查询缓存；但是如果另外一个SqlSession实例进行相同的查询操作，则需要进行数据库查询。</p>
<p>l 针对更新操作，如果是该SqlSession自身进行了更新操作，则该SqlSession对应的一级缓存会被清空；但是如果是其他SqlSession实例进行了更新操作，则此更新操作对该SqlSession不可见。所以该SqlSession的缓存数据是过期失效数据，所以SqlSession实例的生命周期不能过长，否则可能出现数据不一致现象。</p>
<p><strong><em>\</em>STATEMENT级别**</strong></p>
<p>l 该级别是指缓存只针对当前执行的查询语句有效，故每次语句执行完之后都会清空缓存，其实是相当于没有缓存，即该sqlSession实例下次调用相同的SQL语句和相同参数值时，由于上一次语句执行后，缓存被清空了，故需要继续查询数据库。</p>
<p>mybatis的一级缓存是内部实现的一个特性，用户不能配置，默认情况下为开启的。同时内部也是使用一个基于HashMap实现的本地内存来实现，故在配置方面只能配置缓存级别为STATEMENT来关闭一级缓存</p>
<p><strong><em>\</em>二级缓存**</strong></p>
<p>· mybatis默认没有开启二级缓存，<strong><em>\</em>二级缓存支持在配置中自定义底层所用的缓存实现，包括使用本地内存和分布式缓存。**</strong></p>
<p>· 二级缓存是基于namespace的，即作用域为mapper，故需要在每个mapper中配置自身所使用的二级缓存实现以及缓存策略。同时由于二级缓存是基于namespace的，所以不同namespace之间的相互不影响的，如一个namespace使用的本地内存，另外一个namespace使用的是分布式缓存，如果不同namespace对同一张数据表的数据进行了操作，则可能会存在数据不一致问题。</p>
<p>· 如果二级缓存使用本地内存的话，则由于开启二级缓存之后，需要在本地内存缓存大量的数据，即对所有SqlSession实例的查询进行缓存，故可能造成内存资源的开销较大。</p>
<p>虽然一级和二级缓存的使用可以减少数据库查询操作，但是都存在造成数据不一致的情况存在：对于一级缓存由于不同sqlSession实例之间相互隔离，则可能出现其中一个更新了数据库数据，但是另外一个由于使用了自身内部的缓存，故读取到失效的旧数据；对于二级缓存，由所有sqlSession实例共享，基于namespace隔离，故如果不同namespace定义了同时操作一个表的SQL语句，则会造成不同namespace之间的缓存不一致问题。所以如果对于mybatis的内部运作机制不理解，可能会由于这些造成数据不一致的情况存在，则可能会导致莫名其妙的问题。</p>
<p>针对以上这些问题，建议统一使用额外的缓存实现，即在应用代码中自定义缓存实现，关闭mybatis的一级和二级缓存，只使用mybatis基于SQL来进行数据库操作。</p>
<h2 id="第十天"><a href="#第十天" class="headerlink" title="\第十天**"></a><strong><em>\</em>第十天**</strong></h2><h3 id="1、-Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#1、-Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="1、****Mybatis是如何进行分页的？分页插件的原理是什么？****"></a><strong>1、***</strong>*Mybatis是如何进行分页的？分页插件的原理是什么？****</h3><p><strong><em>\</em>在xml中使用sql分页**</strong></p>
<p><strong><em>\</em>使用拦截器分页**</strong></p>
<p>创建拦截器，拦截mybatis接口方法id以ByPage结束的语句</p>
<p><strong><em>\</em>RowBounds分页**</strong></p>
<p>Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分    页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p>
<p>数据量小时，RowBounds不失为一种好办法。但是数据量大时，实现拦截器就很有必要了。</p>
<p>mybatis接口加入RowBounds参数</p>
<p><img src="file:///C:%5CUsers%5C23349%5CAppData%5CLocal%5CTemp%5Cksohtml1160%5Cwps11.jpg" alt="img"> </p>
<p><strong><em>\</em>原理：**</strong></p>
<p>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p>
<h3 id="2、-简述Mybatis的插件运行原理，以及如何编写一个插件"><a href="#2、-简述Mybatis的插件运行原理，以及如何编写一个插件" class="headerlink" title="2、****简述Mybatis的插件运行原理，以及如何编写一个插件****"></a><strong>2、***</strong>*简述Mybatis的插件运行原理，以及如何编写一个插件****</h3><p><strong><em>\</em>拦截器原理**</strong></p>
<p>首先拦截器拦截的是 mybatis 的 4 大对象，我们需要在配置文件中配置拦截器，方便mybaits 添加到拦截器链中。mybatis 为我们提供了 Interceptor 接口，我们可以在该接口中实现自己的逻辑，主要需要实现 intercept 方法，在该方法中利用给定的 Invocation 对象来对我们的业务做一些增强。而调用拦截器方法的类就是 JDK 动态代理的接口 InvocationHandler 的实现类 Plugin 的invoke 方法，该方法会根据目标方法是否匹配拦截器注解的值来决定是否调用拦截器的 intercept 方法。并传入封装了目标对象，目标方法，目标方法参数的 Invocation 实例。</p>
<p><strong><em>\</em>Interceptor 接口*****</strong>*：****</p>
<p>intercept：它将直接覆盖你所拦截的对象，有个参数Invocation对象，通过该对象，可以反射调度原来对象的方法；</p>
<p>plugin：target是被拦截的对象，它的作用是给被拦截对象生成一个代理对象；</p>
<p>setProperties：允许在plugin元素中配置所需参数，该方法在插件初始化的时候会被调用一次；然后把插件对象存入到配置中，以便后续获取。</p>
<p><strong><em>\</em>四大对象：**</strong></p>
<p><strong><em>\</em>Executor：**</strong>调度以下三个对象并且执行SQL全过程，组装参数，执行SQL，组装结果集并返回，通常不怎么拦截使用.</p>
<p><strong><em>\</em>StatementHandler:**</strong>是执行SQL的过程(预处理语句构成)，这里我们可以获得SQL，重写SQL执行。所以这是最常被拦截的对象。</p>
<p><strong><em>\</em>ParameterHandler：**</strong>参数组装，可以拦截参数重组参数。</p>
<p><strong><em>\</em>ResultSetHandler：**</strong>结果集处理，可以重写组装结果集返回。</p>
<p><strong><em>\</em>编写一个插件*****</strong>*(拦截StatementHandler对象)：****</p>
<p>拦截预编译，自然是要拦截StatementHandler的prepare()方法，prepare()方法传入    参数Connection对象和超时参数Integer类型。</p>
<p>@Intercepts({@Signature()})</p>
<p><img src="file:///C:%5CUsers%5C23349%5CAppData%5CLocal%5CTemp%5Cksohtml1160%5Cwps12.jpg" alt="img"> </p>
<p>实现 Interceptor 接口并实现接口中的方法。</p>
<p>实现拦截接口的3个方法</p>
<p>在配置文件中配置插件。</p>
<p>参考：<a href="https://blog.csdn.net/XZLABC12345/article/details/100106407" target="_blank" rel="noopener">https://blog.csdn.net/XZLABC12345/article/details/100106407</a></p>
<h3 id="3、-Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><a href="#3、-Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？" class="headerlink" title="3、****Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？****"></a><strong>3、***</strong>*Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？****</h3><p>第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。</resultMap></p>
<p>第二种是使用sql列的别名功能，将列别名书 写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，Mybatis一样可以正常工作。</p>
<p>有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p>
<h3 id="4、-为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？"><a href="#4、-为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？" class="headerlink" title="4、****为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？****"></a><strong>4、***</strong>*为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？****</h3><p> Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象</p>
<p>时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis 在查询关联对象或<br>关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。</p>
<h3 id="5、-MyBatis-实现一对一有几种方式-具体怎么操作的？"><a href="#5、-MyBatis-实现一对一有几种方式-具体怎么操作的？" class="headerlink" title="5、****MyBatis 实现一对一有几种方式?具体怎么操作的？****"></a><strong>5、***</strong>*MyBatis 实现一对一有几种方式?具体怎么操作的？****</h3><p>有联合查询和嵌套查询<br><strong><em>\</em>联合查询**</strong>是几个表联合查询,只查询一次,通过在 resultMap 里面配置 association 节点配置一对一的类就可以完成;</p>
<p><strong><em>\</em>嵌套查询**</strong>是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过 association 配置,但另外一个表的查询通过 select 属性配置</p>
<h3 id="6、-MyBatis-实现一对多有几种方式-怎么操作的？"><a href="#6、-MyBatis-实现一对多有几种方式-怎么操作的？" class="headerlink" title="6、****MyBatis 实现一对多有几种方式,怎么操作的？****"></a><strong>6、***</strong>*MyBatis 实现一对多有几种方式,怎么操作的？****</h3><p>有联合查询和嵌套查询</p>
<p><strong><em>\</em>联合查询**</strong>是几个表联合查询,只查询一次,通过在resultMap里面配 置collection节点配置一对多的类就可以完成;</p>
<p><strong><em>\</em>嵌套查询**</strong>是先查一个表,根据这个表里面的 结果的外键id,去再另外一个表里面查询数据,也是通过配置collection,但另外一个表的查询通过select节点配置</p>
<h3 id="7、-数据库链接中断如何处理？"><a href="#7、-数据库链接中断如何处理？" class="headerlink" title="7、****数据库链接中断如何处理？****"></a><strong>7、***</strong>*数据库链接中断如何处理？****</h3><p>我们知道，数据库的访问底层是通过tcp实现的，如果数据库链接中断，那么应用程序是不知道的，是探测不出的，那么程序会卡住，一直在等待，会等待吓人的几十分钟，这种情况会把人郁闷死，真不如及时来个弹框，告诉用户系统暂时无法使用，让用户离开呢。所以，面对数据库连接中断的异常，该怎么设置mybatis呢？</p>
<p>要想吃透这个问题，要明白链接中断产生的原因。这里面会涉及到网络通信的问题。在数据库链接中，connection操作可不是计算1+1这样的形式，它低层是个循环处理过程，既然是循环处理过程那么自然就跟时间扯上关系了，跟时间有关的设置有：max_idle_time，connect_timeout。max_idle_time表明最大的空闲时间，超过这个时间socket就会关闭，这样操作系统会省心省力一些，毕竟操作系统维持一个socket也是花费不少精力的。connect_timeout表明链接的超时时间，我们知道，网络环境就是跟潮水一样，一波一波的，总是在波动，既是数据库服务器活的杠杠的，但是因为网络用塞，客户端仍然连不上服务器端，这个时候就要设置timeout，别一直傻等着。</p>
<h3 id="8、-在开发过程中，经常遇到插入重复的现象，这种情况该如何解决呢？"><a href="#8、-在开发过程中，经常遇到插入重复的现象，这种情况该如何解决呢？" class="headerlink" title="8、****在开发过程中，经常遇到插入重复的现象，这种情况该如何解决呢？****"></a><strong>8、***</strong>*在开发过程中，经常遇到插入重复的现象，这种情况该如何解决呢？****</h3><p>先判断是否存在记录，没有存在则插入否则不插入。如果存在并发操作，那么同时进行了第一步，然后大家都发现没有记录，然后都插入了数据从而造成数据的重复。解决插入重复的思路可以是这样的：</p>
<p>（1）判断数据库是否有数据，有的话则无所作为。没有数据的话，则进行下面第2步<br>（2）向redis set key，其中只有一个操作a会成功，其他并发的操作b和c会失败的<br>（3）上面set key 成功的操作a，开始执行插入数据操作，无论是否插入数据成功，都在最后del key。【注】插入不成功可以多尝试几次，增加成功的概率。<br>（4）上面set key 失败的操作b和c，sleep一下，然后再判断数据库是否有数据，有数据则无所做为，没有数据则重复上面的set key，此时是b和c在竞争，失败者则无所作为，成功者则开始插入数据，然后无论插入成功还是失败则都要del key。【注】既然是并发了，本身就是异常情况，就没有必要考虑用户体验了，就可以多sleep一会儿也无妨，不过对于单线程多事件处理的开发模式不要sleep太久。</p>
<p>总之，上面的过程就是：线程a 线程b 线程c，同时插入数据。如果线程a拿到锁之后，让它插入数据，它插入成功了，那么线程b 线程c啥也不用做；它插入失败了，线程b 线程c则抢锁，谁抢到了谁插入数据，不管最后是否成功，程序走到此步就可以了，已经完成了既定两个目标：执行插入，不重复插入。</p>
<h3 id="9、-事务执行过程中宕机的应对处理方"><a href="#9、-事务执行过程中宕机的应对处理方" class="headerlink" title="9、****事务执行过程中宕机的应对处理方****"></a><strong>9、***</strong>*事务执行过程中宕机的应对处理方****</h3><p>答案：不会自动继续执行，不会自动直接回滚，但是可以人工手动选择继续执行或者直接回滚，依据是事务日志。<br>事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是人们口中常说的“日志先行”(Write-Ahead Logging)。<br>日志分为两种类型：redo log和undo log<br>（1）redo log<br>在系统启动的时候，就已经为redo log分配了一块连续的存储空间，以顺序追加的方式记录redo log，通过顺序io来改善性能。所有的事务共享redo log的存储空间，它们的redo log按语句的执行顺序，依次交替的记录在一起。如下一个简单示例：<br>记录1：&lt;trx1, insert…&gt;<br>记录2：&lt;trx2, delete…&gt;<br>记录3：&lt;trx3, update…&gt;<br>记录4：&lt;trx1, update…&gt;<br>记录5：&lt;trx3, insert…&gt;<br>此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。<br>（2）undo log<br>undo log主要为事务的回滚服务。在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。</p>
<p>以下是undo+redo事务的简化过程，假设有2个数值，分别为A和B，值为1，2</p>
<p>\1. start transaction;</p>
<p>\2. 记录 A=1 到undo log;</p>
<p>\3. update A = 3；</p>
<p>\4. 记录 A=3 到redo log；</p>
<p>\5. 记录 B=2 到undo log；</p>
<p>\6. update B = 4；</p>
<p>\7. 记录B = 4 到redo log；</p>
<p>\8. 将redo log刷新到磁盘</p>
<p>\9. commit</p>
<p>在1-8的任意一步系统宕机，事务未提交，该事务就不会对磁盘上的数据做任何影响。如果在8-9之间宕机，恢复之后可以选择回滚，也可以选择继续完成事务提交，因为此时redo log已经持久化。若在9之后系统宕机，内存映射中变更的数据还来不及刷回磁盘，那么系统恢复之后，可以根据redo log把数据刷回磁盘。所以，redo log其实保障的是事务的持久性和一致性，而undo log则保障了事务的原子性。</p>
<h3 id="10、-Java客户端中的一个Connection是不是在MySQL中就对应一个线程来处理这个链接呢？"><a href="#10、-Java客户端中的一个Connection是不是在MySQL中就对应一个线程来处理这个链接呢？" class="headerlink" title="10、****Java客户端中的一个Connection是不是在MySQL中就对应一个线程来处理这个链接呢？****"></a><strong>10、***</strong>*Java客户端中的一个Connection是不是在MySQL中就对应一个线程来处理这个链接呢？****</h3><p>不是。凡是从线程思考问题的人，一般都是被Java技术的多线程思想所禁锢了，其实在高性能服务器端开发底层往往靠io复用来处理，这种模式就是：单线程+事件处理机制。在MySQL里面往往有一个主线程，这是单线程（与Java中处处强调多线程的思想有点不同哦），它不断的循环查看是否有socket是否有读写事件，如果有读写事件，再从线程池里面找个工作线程处理这个socket的读写事件，完事之后工作线程会回到线程池。所以：Java客户端中的一个Connection不是在MySQL中就对应一个线程来处理这个链接，而是由监听socket的主线程+线程池里面固定数目的工作线程来处理的。</p>
<h2 id="第十一天"><a href="#第十一天" class="headerlink" title="\第十一天**"></a><strong><em>\</em>第十一天**</strong></h2><h3 id="1、-springmvc运行流程？"><a href="#1、-springmvc运行流程？" class="headerlink" title="1、****springmvc运行流程？****"></a><strong>1、***</strong>*springmvc运行流程？****</h3><p>1.客户端浏览器向前端控制器（DispatcherServlet）发出请求。</p>
<p>2.DispatcherServlet接收到请求后，调用处理器映射器（HandlerMapping）。</p>
<p>3.HandlerMapping根据请求url查找相应的处理器（Handler，也称后端控制器），返回处理器对象（Handler），并且如果有处理器拦截器（HandlerInterceptor）的话，会将处理器对象（Handler）和处理器拦截器对象（HandlerInterceptor）一并返回给DispatcherServlet。</p>
<p>4.DispatcherServlet拿到这些信息后，会调用处理器适配器（HandlerAdapter），HandlerAdapter会执行Handler，Handler执行处理DispatcherServlet发来的请求，生成<strong><em>\</em>ModelAndView**</strong>对象返回给HandlerAdapter。</p>
<p>5.HandlerAdapter将<strong><em>\</em>ModelAndView**</strong>对象返回给DispatcherServlet。</p>
<p>6.DispatcherServlet在拿到<strong><em>\</em>ModelAndView**</strong>对象之后，将<strong><em>\</em>ModelAndView**</strong>对象发给视图解析器（ViewResolver）。</p>
<p>7.ViewResolver将<strong><em>\</em>ModelAndView**</strong>对象进行解析，生成<strong><em>\</em>View**</strong>对象，将<strong><em>\</em>View**</strong>对象返回给DispatcherServlet。</p>
<p>8.DispatcherServlet拿到<strong><em>\</em>View**</strong>对象，对jsp页面进行渲染（将模型数据填充到视图中），将渲染后的页面呈现给用户。</p>
<h3 id="2、-Spring-MVC的主要组件有哪些？分别简述一下"><a href="#2、-Spring-MVC的主要组件有哪些？分别简述一下" class="headerlink" title="2、****Spring MVC的主要组件有哪些？分别简述一下****"></a><strong>2、***</strong>*Spring MVC的主要组件有哪些？分别简述一下****</h3><p>前端控制器（DispatcherServlet）：主要负责捕获来自客户端的请求和调度各个组件。</p>
<p>处理器映射器（HandlerMapping）：根据url查找后端控制器Handler。</p>
<p>处理器适配器（HandlerAdapter）：执行后端控制器（Handler），拿到后端控制器返回的结果ModelAndView后将结果返回给前端控制器DispatcherServlet。</p>
<p>后端控制器（处理器）（Handler）：主要负责处理前端请求，完成业务逻辑，生成ModelAndView对象返回给HandlerAdapter。</p>
<p>视图解析器（ViewResolver）：主要负责将从DispatcherServlet中拿到的ModelAndView对象进行解析，生成View对象返回给DispatcherServlet。</p>
<h3 id="3、-8-Mvc怎么和AJAX相互调用的？"><a href="#3、-8-Mvc怎么和AJAX相互调用的？" class="headerlink" title="3、****8****Mvc怎么和AJAX相互调用的？****"></a><strong>3、***</strong>*8*<strong>**</strong>*Mvc怎么和AJAX相互调用的？****</h3><p>通过Jackson框架就可以把Java里面的对象直接转化成Js可以识别的Json对象。具体步骤如下 ：</p>
<p>（1）加入Jackson.jar<br>（2）在配置文件中配置json的映射<br>（3）在接受Ajax方法里面可以直接返回Object,List等,但方法前面要加上@ResponseBody注解。</p>
<h3 id="4、-如何解决POST请求中文乱码问题，GET的又如何处理呢？"><a href="#4、-如何解决POST请求中文乱码问题，GET的又如何处理呢？" class="headerlink" title="4、****如何解决POST请求中文乱码问题，GET的又如何处理呢？****"></a><strong>4、***</strong>*如何解决POST请求中文乱码问题，GET的又如何处理呢？****</h3><h4 id="（-1-）-解决post请求乱码问题："><a href="#（-1-）-解决post请求乱码问题：" class="headerlink" title="\（******1****）****解决post请求乱码问题：****"></a><strong><em>\</em>（*****</strong>*1*<strong>**</strong>*）*<strong>**</strong>*解决post请求乱码问题：****</h4><p>①　在代码前加上request.setCharacterEncoding(“UTF-8”)</p>
<p>②　在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8；<img src="file:///C:%5CUsers%5C23349%5CAppData%5CLocal%5CTemp%5Cksohtml1160%5Cwps13.png" alt="img"></p>
<h4 id="（2）get请求中文参数出现乱码解决方法："><a href="#（2）get请求中文参数出现乱码解决方法：" class="headerlink" title="\（2）get请求中文参数出现乱码解决方法：**"></a><strong><em>\</em>（2）get请求中文参数出现乱码解决方法：**</strong></h4><p>①修改tomcat配置文件添加编码与工程编码一致，如下：</p>
<p>&lt;ConnectorURIEncoding=”utf-8” connectionTimeout=”20000” port=”8080” protocol=”HTTP/1.1” redirectPort=”8443”/&gt;</p>
<p>②另外一种方法对参数进行重新编码：</p>
<p>String userName = new String(request.getParamter(“userName”).getBytes(“ISO8859-1”),”utf-8”)</p>
<p><strong><em>\</em>注：**</strong>ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。</p>
<h3 id="5、-SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决？"><a href="#5、-SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决？" class="headerlink" title="5、****SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？****"></a><strong>5、***</strong>*SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？****</h3><p>是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的。</p>
<p>解决方案是在控制器里面不能写成员变量。</p>
<p><strong><em>\</em>为什么设计成单例模式？**</strong></p>
<p>①性能 （不用每次请求都创建对象）</p>
<p>②不需要多例（不要在控制器类中定义成员变量，只要controller中不定义属性，那么单例完全是安全的。）</p>
<p>1、不要在controller中定义成员变量。</p>
<p>2、万一必须要定义一个非静态成员变量时候，则通过注解@Scope(“prototype”)，将其设置为多例模式</p>
<h5 id="成员变量"><a href="#成员变量" class="headerlink" title="\成员变量**"></a><strong><em>\</em>成员变量**</strong></h5><p>· 成员变量定义在类中，在整个类中都可以被访问。</p>
<p>· 成员变量随着对象的建立而建立，随着对象的消失而消失，存在于对象所在的堆内存中。</p>
<p>· 成员变量有默认初始化值。</p>
<p>但是，很多人学习都是先学习的C语言，C语言中存在全局变量这个概念，所以，大家对于Java中的成员变量有时候也称之为全局变量，同时也存在如下的一个约定俗成的小区别</p>
<p><strong><em>\</em>使用static 关键字进行声明的变量叫做全局变量**</strong></p>
<p><strong><em>\</em>在函数外面定义的变量叫做成员变量**</strong></p>
<h3 id="6、-SpringMVC常用的注解有哪些？"><a href="#6、-SpringMVC常用的注解有哪些？" class="headerlink" title="6、****SpringMVC常用的注解有哪些？****"></a><strong>6、***</strong>*SpringMVC常用的注解有哪些？****</h3><p>@Component 在类定义之前添加@Component注解，他会被spring容器识别，并转为bean。</p>
<p>@Repository 对Dao实现类进行注解 (特殊的@Component)</p>
<p>@Service 用于对业务逻辑层进行注解， (特殊的@Component)</p>
<p>@Controller 用于控制层注解 ， (特殊的@Component)</p>
<p>@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。<br>@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。<br>@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。</p>
<p>@RequestParam：用于获取传入参数的值</p>
<p>@PathViriable：用于定义路径参数值</p>
<h3 id="7、-SpringMvc里面拦截器是怎么写？"><a href="#7、-SpringMvc里面拦截器是怎么写？" class="headerlink" title="7、****SpringMvc里面拦截器是怎么写？****"></a><strong>7、***</strong>*SpringMvc里面拦截器是怎么写？****</h3><p>有两种写法,一种是实现HandlerInterceptor接口，</p>
<p>另外一种是继承适配器类，接着在接口方法当中，实现处理逻辑；然后在SpringMvc的配置文件中配置拦截器即可：<br>xml </p>
<!-- 配置SpringMvc的拦截器 -->

<p> <a href="mvc:interceptors">mvc:interceptors</a> </p>
<!-- 配置一个拦截器的Bean就可以了 默认是对所有请求都拦截--> 

<p><bean id="myInterceptor" class="com.zwp.action.MyHandlerInterceptor"></bean> <!-- 只针对部分请求拦截 --> </p>
<p><a href="mvc:interceptor">mvc:interceptor</a> </p>
<p>&lt;mvc:mapping path=”/modelMap.do”/&gt; </p>
<p><bean class="com.zwp.action.MyHandlerInterceptorAdapter">  </bean></p>
<p></p>
<h3 id="8、-springmvc-DispatcherServlet与handlerAdapter如何关联"><a href="#8、-springmvc-DispatcherServlet与handlerAdapter如何关联" class="headerlink" title="8、****springmvc DispatcherServlet与handlerAdapter如何关联?****"></a><strong>8、***</strong>*springmvc DispatcherServlet与handlerAdapter如何关联?****</h3><p>DispatcherServlet拦截到请求之后,根据handlerMapping获取到handlerExecutionChain对象,然后,在handlerExecutionChain对象不为null的情况下,根据handlerExecutionChain中的handler对象获取HandlerAdapter对象;</p>
<h3 id="9、-有了springmvc的IOC容器-还需要spring的IOC容器吗-为什么-如何处理兼容问题"><a href="#9、-有了springmvc的IOC容器-还需要spring的IOC容器吗-为什么-如何处理兼容问题" class="headerlink" title="9、****有了springmvc的IOC容器,还需要spring的IOC容器吗?为什么?如何处理兼容问题?****"></a><strong>9、***</strong>*有了springmvc的IOC容器,还需要spring的IOC容器吗?为什么?如何处理兼容问题?****</h3><p>这个问题再进一步,换个方式提问即是否还需要在web.xml方法里面配置启动springIOC容器的ContextLoaderListener?<br>可以从正反两方面来回答,</p>
<p>首先是需要,通常情况下,类似于数据源,事务,整合其他框架等都是放在spring的配置文件中,而不是springmvc的配置文件中, 一般情况下,开发过程中的Service,Dao也都是放在spring的IOC容器当中;</p>
<p>其次可以是不需要的,也可以都放在springmvc的配置文件当中,当然需要分多个spring的配置文件,然后通过import节点导入到springmvc的配置文件当中.<br><strong><em>\</em>几点要注意的地方:*****</strong>*<br>****1. springIOC容器和springmvc的IOC容器 扫描的部分有重合的地方,就会导致bean被创建2次,</p>
<p>解决方案:</p>
<p>使用 exclude-filter和include-filter配合来区分哪些bean交给springIOC容器,哪些bean交给springmvcIOC容器;<br>\2. springmvc IOC容器里面的bean可以引用springIOC容器的bean,反之则不行,多个springIOC 容器之间可以设置为父子关系,以实现良好的解耦.举个栗子,springIOC容器好比是全局作用域,springmvcIOC容器好比是局部作用域,局部的可以引用全局的,而全局的却不能引用局部的.</p>
<h3 id="10、-Spring-MVC-怎么做异常处理？"><a href="#10、-Spring-MVC-怎么做异常处理？" class="headerlink" title="10、****Spring MVC 怎么做异常处理？****"></a><strong>10、***</strong>*Spring MVC 怎么做异常处理？****</h3><p><strong><em>\</em>1、*****</strong>*使用 @ ExceptionHandler 注解*<strong>**</strong>*(方法)****</p>
<p>使用该注解有一个不好的地方就是：进行异常处理的方法必须与出错的方法在同一个Controller里面。</p>
<p> 如果 @ExceptionHandler 注解中未声明要处理的异常类型，则默认为参数列表中的异常类型。</p>
<p><strong><em>\</em>2、*****</strong>*使用 @ControllerAdvice*<strong>**</strong>*(类)*<strong>**</strong>*+ @ ExceptionHandler 注解****</p>
<p>上文说到 @ ExceptionHandler 需要进行异常处理的方法必须与出错的方法在同一个Controller里面。那么当代码加入了 @ControllerAdvice，则不需要必须在同一个 controller 中了。这也是 Spring 3.2 带来的新特性。从名字上可以看出大体意思是控制器增强。 也就是说，@controlleradvice + @ ExceptionHandler 也可以实现全局的异常捕捉。</p>
<p><strong><em>\</em>请确保*****</strong>*这个*<strong>**</strong>*类能被扫描到并装载进 Spring 容器中。****</p>
<p><strong><em>\</em>3、*****</strong>*实现 HandlerExceptionResolver 接口****</p>
<p>这种方式可以进行全局的异常控制。</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='https://link.hhtjim.com/qq/000OW10n2Fq4WF.mp3'></li>
                        
                    
                        
                            <li title='1' data-url='https://link.hhtjim.com/qq/004Ti8rT003TaZ.mp3'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
        data-ae='true'
        data-ci='4cde5b799d0aa4031ad9'
        data-cs='0338981ce6bf02ba13ceb64c06e74748b297d7dc'
        data-r='SunZune'
        data-o='SunZune'
        data-a='SunZune'
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#面试题"><span class="toc-number">1.</span> <span class="toc-text">\面试题**</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一天"><span class="toc-number">1.1.</span> <span class="toc-text">\第一天**</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1、简单说说线程的几种状态-以及线程的阻塞的方式"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">\1、简单说说线程的几种状态 以及线程的阻塞的方式**</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2、简单说说hashmap的底层实现原理"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">\2、简单说说hashmap的底层实现原理**</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3、一万个人抢100个红包，如何实现（不用队列），如何保证2个人不能抢到同一个红包，可用分布式锁"><span class="toc-number">1.1.0.3.</span> <span class="toc-text">\3、一万个人抢100个红包，如何实现（不用队列），如何保证2个人不能抢到同一个红包，可用分布式锁**</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4、两个Integer的引用对象传给一个swap方法在方法内部交换引用，返回后，两个引用的值是否会发现变化，原因是什么？"><span class="toc-number">1.1.0.4.</span> <span class="toc-text">\4、两个Integer的引用对象传给一个swap方法在方法内部交换引用，返回后，两个引用的值是否会发现变化，原因是什么？**</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5、-aop的底层实现，动态代理是如何动态，假如有100个对象，如何动态的为这100个对象代理"><span class="toc-number">1.1.0.5.</span> <span class="toc-text">5、****aop的底层实现，动态代理是如何动态，假如有100个对象，如何动态的为这100个对象代理****</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6、spring的bean配置的几种方式？"><span class="toc-number">1.1.0.6.</span> <span class="toc-text">\6、spring的bean配置的几种方式？**</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7、说说spring的监听器的实现原理？"><span class="toc-number">1.1.0.7.</span> <span class="toc-text">\7、说说spring的监听器的实现原理？**</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8、java有哪些锁？乐观锁-悲观锁-synchronized-可重入锁-读写锁-用过reentrantlock吗？reentrantlock与synmchronized的区别"><span class="toc-number">1.1.0.8.</span> <span class="toc-text">\8、java有哪些锁？乐观锁 悲观锁 synchronized 可重入锁 读写锁,用过reentrantlock吗？reentrantlock与synmchronized的区别**</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9、-说说你了解的ThreadLocal的使用场景"><span class="toc-number">1.1.0.9.</span> <span class="toc-text">9、****说说你了解的ThreadLocal的使用场景****</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10、为什么线程执行要调用start而不是直接run（直接run，跟普通方法没什么区别，先调start，run才会作为一个线程方法运行）"><span class="toc-number">1.1.0.10.</span> <span class="toc-text">\10、为什么线程执行要调用start而不是直接run（直接run，跟普通方法没什么区别，先调start，run才会作为一个线程方法运行）**</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第二天"><span class="toc-number">1.2.</span> <span class="toc-text">\第二天**</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、简单说说memcache和redis的两种缓存的区别以及分别使用什么样的项目中？"><span class="toc-number">1.2.1.</span> <span class="toc-text">\1、简单说说memcache和redis的两种缓存的区别以及分别使用什么样的项目中？**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、-简单讲讲mysql的锁机制以及的行级锁加在哪个位置？"><span class="toc-number">1.2.2.</span> <span class="toc-text">2、****简单讲讲mysql的锁机制以及的行级锁加在哪个位置？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、-你了解的Mysql的几种引擎？-分别适合什么样的数据库"><span class="toc-number">1.2.3.</span> <span class="toc-text">3、****你了解的Mysql的几种引擎？ 分别适合什么样的数据库****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、-mysql的性能优化方式有哪些，你用过哪几种，分别在什么情况下去使用的"><span class="toc-number">1.2.4.</span> <span class="toc-text">4、****mysql的性能优化方式有哪些，你用过哪几种，分别在什么情况下去使用的****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、-谈谈你对Java垃圾回收机制的了解"><span class="toc-number">1.2.5.</span> <span class="toc-text">5、****谈谈你对Java垃圾回收机制的了解****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、-你是否用过Autowire注解，它的实现原理是什么"><span class="toc-number">1.2.6.</span> <span class="toc-text">6、****你是否用过Autowire注解，它的实现原理是什么****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、-讲一讲java中的final和static以及你熟悉的Java中使用final修饰的类"><span class="toc-number">1.2.7.</span> <span class="toc-text">\7、******讲一讲java中的final和static以及你熟悉的Java中使用final修饰的类****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、-讲讲Java中线程安全的问题，以及常用的一些手段控制线程安全包括他们的优劣势"><span class="toc-number">1.2.8.</span> <span class="toc-text">\8、******讲讲Java中线程安全的问题，以及常用的一些手段控制线程安全包括他们的优劣势****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9、-线程安全的单例模式是怎么实现的？-原理是什么？"><span class="toc-number">1.2.9.</span> <span class="toc-text">9、****线程安全的单例模式是怎么实现的？ 原理是什么？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10、-java中几种集合的区别以及底层实现是什么样的？"><span class="toc-number">1.2.10.</span> <span class="toc-text">10、****java中几种集合的区别以及底层实现是什么样的？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null"><span class="toc-number">1.2.11.</span> <span class="toc-text"></span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第三天"><span class="toc-number">1.3.</span> <span class="toc-text">\第三天**</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、聊聊Java中序列化以及反序列的作用，类序列化时类的版本号的用途，如果没有指定一个版本号，系统是怎么处理的？如果加了字段会怎么样？"><span class="toc-number">1.3.1.</span> <span class="toc-text">\1、聊聊Java中序列化以及反序列的作用，类序列化时类的版本号的用途，如果没有指定一个版本号，系统是怎么处理的？如果加了字段会怎么样？**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、介绍一下MyBatis的缓存？"><span class="toc-number">1.3.2.</span> <span class="toc-text">\2、介绍一下MyBatis的缓存？**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、讲一讲javaWeb中的四种会话跟踪技术"><span class="toc-number">1.3.3.</span> <span class="toc-text">\3、讲一讲javaWeb中的四种会话跟踪技术**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、描述一下JVM加载class文件的原理机制"><span class="toc-number">1.3.4.</span> <span class="toc-text">\4、描述一下JVM加载class文件的原理机制?**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、同步和异步有什么异同，在什么情况下分别使用他们？举例说明"><span class="toc-number">1.3.5.</span> <span class="toc-text">\5、同步和异步有什么异同，在什么情况下分别使用他们？举例说明**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、请说出你所知道的线程同步的方法"><span class="toc-number">1.3.6.</span> <span class="toc-text">\6、请说出你所知道的线程同步的方法**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、什么是aop，aop的作用是什么-aop中的关键名词有些那些，相互关系是什么"><span class="toc-number">1.3.7.</span> <span class="toc-text">\7、什么是aop，aop的作用是什么?aop中的关键名词有些那些，相互关系是什么?**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、在spring中有几种事务管理，分别是什么"><span class="toc-number">1.3.8.</span> <span class="toc-text">\8、在spring中有几种事务管理，分别是什么?**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9、String类为什么是final的？"><span class="toc-number">1.3.9.</span> <span class="toc-text">\9、String类为什么是final的？**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10、session和cookie的区别和联系，session的生命周期，多个服务部署时session管理"><span class="toc-number">1.3.10.</span> <span class="toc-text">\10、session和cookie的区别和联系，session的生命周期，多个服务部署时session管理**</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第四天"><span class="toc-number">1.4.</span> <span class="toc-text">\第四天**</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、-为什么重写equals时必须重写hashCode方法？"><span class="toc-number">1.4.1.</span> <span class="toc-text">1、****为什么重写equals时必须重写hashCode方法？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、-Java-中的异常分类和处理机制"><span class="toc-number">1.4.2.</span> <span class="toc-text">2、****Java 中的异常分类和处理机制****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、-Java序列化中如果有些字段不想进行序列化-怎么办"><span class="toc-number">1.4.3.</span> <span class="toc-text">\3、******Java序列化中如果有些字段不想进行序列化 怎么办****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、-讲讲Java中的字符串不可变和字符串池"><span class="toc-number">1.4.4.</span> <span class="toc-text">4、*****讲讲Java中的字符串不可变和字符串池****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、-线程中wait-和sleep-的区别？"><span class="toc-number">1.4.5.</span> <span class="toc-text">5、****线程中wait 和sleep 的区别？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、-List-和-Set-的区别？"><span class="toc-number">1.4.6.</span> <span class="toc-text">6、****List 和 Set 的区别？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、-HashSet-是如何保证不重复的"><span class="toc-number">1.4.7.</span> <span class="toc-text">7、****HashSet 是如何保证不重复的****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、-java中数组在内存中如何分配？"><span class="toc-number">1.4.8.</span> <span class="toc-text">8、****java中数组在内存中如何分配？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9、-什么是多线程环境下的伪共享（false-sharing）？"><span class="toc-number">1.4.9.</span> <span class="toc-text">9、****什么是多线程环境下的伪共享（false sharing）？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10、-解释Java堆空间及GC"><span class="toc-number">1.4.10.</span> <span class="toc-text">10、****解释Java堆空间及GC****</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第五天"><span class="toc-number">1.5.</span> <span class="toc-text">\第五天**</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、-java中操作字符串都有哪些类？它们之间有什么区别？"><span class="toc-number">1.5.1.</span> <span class="toc-text">1、****java中操作字符串都有哪些类？它们之间有什么区别？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、-BIO、NIO、AIO-有什么区别？"><span class="toc-number">1.5.2.</span> <span class="toc-text">2、****BIO、NIO、AIO 有什么区别？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、-？并简线程有哪些状态单解释一下每个状态"><span class="toc-number">1.5.3.</span> <span class="toc-text">3、****？并简线程有哪些状态单解释一下每个状态****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、-java程序中怎么保证多线程的运行安全？"><span class="toc-number">1.5.4.</span> <span class="toc-text">4、****java程序中怎么保证多线程的运行安全？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、-什么是死锁？怎么防止死锁"><span class="toc-number">1.5.5.</span> <span class="toc-text">5、****什么是死锁？怎么防止死锁****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、synchronized-、-volatile-、Lock-、ReentrantLock-的区"><span class="toc-number">1.5.6.</span> <span class="toc-text">\6、synchronized 、 volatile 、Lock 、ReentrantLock  的区**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#别是什么？"><span class="toc-number">1.5.7.</span> <span class="toc-text">\别是什么？**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、-动态代理是什么？在spring中有哪些应用？"><span class="toc-number">1.5.8.</span> <span class="toc-text">\7、******动态代理是什么？在spring中有哪些应用？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、-什么是-CSRF-攻击，如何避免？"><span class="toc-number">1.5.9.</span> <span class="toc-text">8、****什么是 CSRF 攻击，如何避免？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9、-简述-tcp-和-udp的区别？"><span class="toc-number">1.5.10.</span> <span class="toc-text">9、****简述 tcp 和 udp的区别？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10、-tcp为什么要三次握手，两次不行吗？为什么？"><span class="toc-number">1.5.11.</span> <span class="toc-text">10、****tcp为什么要三次握手，两次不行吗？为什么？****</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第六天"><span class="toc-number">1.6.</span> <span class="toc-text">\第六天**</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、-Java中如何实现跨域？"><span class="toc-number">1.6.1.</span> <span class="toc-text">1、****Java中如何实现跨域？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、-简单工厂和抽象工厂有什么区别？"><span class="toc-number">1.6.2.</span> <span class="toc-text">2、****简单工厂和抽象工厂有什么区别？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、-解释一下什么是-aop？什么是IOC？"><span class="toc-number">1.6.3.</span> <span class="toc-text">3、****解释一下什么是 aop？什么是IOC？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、-spring-常用的注入方式有哪些？"><span class="toc-number">1.6.4.</span> <span class="toc-text">4、****spring 常用的注入方式有哪些？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、-spring-中的-bean-是线程安全的吗？支持几种-bean-的作用域？"><span class="toc-number">1.6.5.</span> <span class="toc-text">5、****spring 中的 bean 是线程安全的吗？支持几种 bean 的作用域？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、-什么是spring-的事务隔离？spring-事务实现方式有哪些？"><span class="toc-number">1.6.6.</span> <span class="toc-text">6、****什么是spring 的事务隔离？spring 事务实现方式有哪些？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、-说一下-SpringMVC-运行流程？"><span class="toc-number">1.6.7.</span> <span class="toc-text">7、****说一下****SpringMVC** **运行流程？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、-简述-Spring-IoC-的实现机制？"><span class="toc-number">1.6.8.</span> <span class="toc-text">8、****简述 Spring IoC 的实现机制？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9、-Spring-Bean-在容器的生命周期是什么样的？"><span class="toc-number">1.6.9.</span> <span class="toc-text">9、****Spring Bean 在容器的生命周期是什么样的？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#-1"><span class="toc-number">1.6.10.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10、-解释什么叫延迟加载？"><span class="toc-number">1.6.11.</span> <span class="toc-text">10、****解释什么叫延迟加载？****</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第七天"><span class="toc-number">1.7.</span> <span class="toc-text">\第七天**</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、Spring中AOP-有哪些实现方式？"><span class="toc-number">1.7.1.</span> <span class="toc-text">\1、Spring中AOP 有哪些实现方式？**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、简述一下Spring中的事务的实现方式？"><span class="toc-number">1.7.2.</span> <span class="toc-text">\2、简述一下Spring中的事务的实现方式？**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、动态代理与cglib实现的区别？"><span class="toc-number">1.7.3.</span> <span class="toc-text">\3、动态代理与cglib实现的区别？**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、-Spring-Framework-有哪些不同的功能？"><span class="toc-number">1.7.4.</span> <span class="toc-text">4、****Spring Framework 有哪些不同的功能？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、-spring-提供了哪些配置方式？"><span class="toc-number">1.7.5.</span> <span class="toc-text">5、****spring 提供了哪些配置方式？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、-说下对IOC容器的理解以及IOC容器是怎么工作的？"><span class="toc-number">1.7.6.</span> <span class="toc-text">6、****说下对IOC容器的理解以及IOC容器是怎么工作的？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、-BeanFactory和ApplicationContext的区别是什么？"><span class="toc-number">1.7.7.</span> <span class="toc-text">7、****BeanFactory和ApplicationContext的区别是什么？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、-Spring-Aop和AspecJ-Aop有什么区别？"><span class="toc-number">1.7.8.</span> <span class="toc-text">\8、******Spring Aop和AspecJ Aop有什么区别？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9、-Spring中的bean都有哪些作用域？"><span class="toc-number">1.7.9.</span> <span class="toc-text">\9、******Spring中的bean都有哪些作用域？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10、-简述一下Spring中的单例Bean的线程安全问题？"><span class="toc-number">1.7.10.</span> <span class="toc-text">10、****简述一下Spring中的单例Bean的线程安全问题？****</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第八天"><span class="toc-number">1.8.</span> <span class="toc-text">\第八天**</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、-你使用过Spring的事务吗？是怎么用的？"><span class="toc-number">1.8.1.</span> <span class="toc-text">1、****你使用过Spring的事务吗？是怎么用的？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、Spring的事务有哪几种隔离级别"><span class="toc-number">1.8.2.</span> <span class="toc-text">\2、Spring的事务有哪几种隔离级别?**</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、-Spring事务有哪几种事务传播行为？"><span class="toc-number">1.8.3.</span> <span class="toc-text">\3、******Spring事务有哪几种事务传播行为？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、-spring-JDBC-API-中存在哪些类？"><span class="toc-number">1.8.4.</span> <span class="toc-text">4、****spring JDBC API 中存在哪些类？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、-简单的说一下spring的生命周期？"><span class="toc-number">1.8.5.</span> <span class="toc-text">5、****简单的说一下spring的生命周期？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、-Spring如何处理线程并发问题？"><span class="toc-number">1.8.6.</span> <span class="toc-text">6、****Spring如何处理线程并发问题？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、-解释一下Spring-AOP里面的几个名词？"><span class="toc-number">1.8.7.</span> <span class="toc-text">7、****解释一下Spring AOP里面的几个名词？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、-解释spring中不同方式的自动装配"><span class="toc-number">1.8.8.</span> <span class="toc-text">8、****解释spring中不同方式的自动装配****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9、-ApplicationContext通常的实现是什么？"><span class="toc-number">1.8.9.</span> <span class="toc-text">9、****ApplicationContext通常的实现是什么？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10、什么是基于Java的Spring注解配置-给一些常见注解的例子"><span class="toc-number">1.8.10.</span> <span class="toc-text">\10、什么是基于Java的Spring注解配置? 给一些常见注解的例子**</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第九天"><span class="toc-number">1.9.</span> <span class="toc-text">\第九天**</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、-和-的区别是什么？"><span class="toc-number">1.9.1.</span> <span class="toc-text">1、****#{} 和 ${} 的区别是什么？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、-当实体类中的属性名和表中的字段名不一样时有哪些处理方法？"><span class="toc-number">1.9.2.</span> <span class="toc-text">2、****当实体类中的属性名和表中的字段名不一样时有哪些处理方法？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、-Mybatis-动态-SQL-是做什么的？都有哪些动态-SQL-？能简述一下动态-SQL-的执行原理吗？"><span class="toc-number">1.9.3.</span> <span class="toc-text">3、****Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、-通常一个-XML-映射文件，都会写一个-Mapper-接口与之对应。请问，这个-Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？"><span class="toc-number">1.9.4.</span> <span class="toc-text">4、****通常一个 XML 映射文件，都会写一个 Mapper 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、-Mapper接口绑定有几种实现方式-分别是怎么实现的"><span class="toc-number">1.9.5.</span> <span class="toc-text">5、****Mapper接口绑定有几种实现方式,分别是怎么实现的?****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、-在mybatis中如何获取自动生成的-主-键值"><span class="toc-number">1.9.6.</span> <span class="toc-text">6、****在mybatis中如何获取自动生成的(主)键值?****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、-在-Mapper-中如何传递多个参数"><span class="toc-number">1.9.7.</span> <span class="toc-text">7、****在 Mapper 中如何传递多个参数?****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、-Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><span class="toc-number">1.9.8.</span> <span class="toc-text">8、****Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9、-MyBatis-执行批量插入有哪些方式？-优缺点是什么"><span class="toc-number">1.9.9.</span> <span class="toc-text">9、****MyBatis 执行批量插入有哪些方式？ 优缺点是什么?****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10、介绍-MyBatis-的一级缓存和二级缓存的概念和实现原理？"><span class="toc-number">1.9.10.</span> <span class="toc-text">\10、介绍 MyBatis 的一级缓存和二级缓存的概念和实现原理？**</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第十天"><span class="toc-number">1.10.</span> <span class="toc-text">\第十天**</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、-Mybatis是如何进行分页的？分页插件的原理是什么？"><span class="toc-number">1.10.1.</span> <span class="toc-text">1、****Mybatis是如何进行分页的？分页插件的原理是什么？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、-简述Mybatis的插件运行原理，以及如何编写一个插件"><span class="toc-number">1.10.2.</span> <span class="toc-text">2、****简述Mybatis的插件运行原理，以及如何编写一个插件****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、-Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？"><span class="toc-number">1.10.3.</span> <span class="toc-text">3、****Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、-为什么说-Mybatis-是半自动-ORM-映射工具？它与全自动的区别在哪里？"><span class="toc-number">1.10.4.</span> <span class="toc-text">4、****为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、-MyBatis-实现一对一有几种方式-具体怎么操作的？"><span class="toc-number">1.10.5.</span> <span class="toc-text">5、****MyBatis 实现一对一有几种方式?具体怎么操作的？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、-MyBatis-实现一对多有几种方式-怎么操作的？"><span class="toc-number">1.10.6.</span> <span class="toc-text">6、****MyBatis 实现一对多有几种方式,怎么操作的？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、-数据库链接中断如何处理？"><span class="toc-number">1.10.7.</span> <span class="toc-text">7、****数据库链接中断如何处理？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、-在开发过程中，经常遇到插入重复的现象，这种情况该如何解决呢？"><span class="toc-number">1.10.8.</span> <span class="toc-text">8、****在开发过程中，经常遇到插入重复的现象，这种情况该如何解决呢？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9、-事务执行过程中宕机的应对处理方"><span class="toc-number">1.10.9.</span> <span class="toc-text">9、****事务执行过程中宕机的应对处理方****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10、-Java客户端中的一个Connection是不是在MySQL中就对应一个线程来处理这个链接呢？"><span class="toc-number">1.10.10.</span> <span class="toc-text">10、****Java客户端中的一个Connection是不是在MySQL中就对应一个线程来处理这个链接呢？****</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第十一天"><span class="toc-number">1.11.</span> <span class="toc-text">\第十一天**</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、-springmvc运行流程？"><span class="toc-number">1.11.1.</span> <span class="toc-text">1、****springmvc运行流程？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、-Spring-MVC的主要组件有哪些？分别简述一下"><span class="toc-number">1.11.2.</span> <span class="toc-text">2、****Spring MVC的主要组件有哪些？分别简述一下****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、-8-Mvc怎么和AJAX相互调用的？"><span class="toc-number">1.11.3.</span> <span class="toc-text">3、****8****Mvc怎么和AJAX相互调用的？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、-如何解决POST请求中文乱码问题，GET的又如何处理呢？"><span class="toc-number">1.11.4.</span> <span class="toc-text">4、****如何解决POST请求中文乱码问题，GET的又如何处理呢？****</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#（-1-）-解决post请求乱码问题："><span class="toc-number">1.11.4.1.</span> <span class="toc-text">\（******1****）****解决post请求乱码问题：****</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#（2）get请求中文参数出现乱码解决方法："><span class="toc-number">1.11.4.2.</span> <span class="toc-text">\（2）get请求中文参数出现乱码解决方法：**</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、-SpringMvc的控制器是不是单例模式-如果是-有什么问题-怎么解决？"><span class="toc-number">1.11.5.</span> <span class="toc-text">5、****SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？****</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#成员变量"><span class="toc-number">1.11.5.0.1.</span> <span class="toc-text">\成员变量**</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、-SpringMVC常用的注解有哪些？"><span class="toc-number">1.11.6.</span> <span class="toc-text">6、****SpringMVC常用的注解有哪些？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7、-SpringMvc里面拦截器是怎么写？"><span class="toc-number">1.11.7.</span> <span class="toc-text">7、****SpringMvc里面拦截器是怎么写？****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8、-springmvc-DispatcherServlet与handlerAdapter如何关联"><span class="toc-number">1.11.8.</span> <span class="toc-text">8、****springmvc DispatcherServlet与handlerAdapter如何关联?****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9、-有了springmvc的IOC容器-还需要spring的IOC容器吗-为什么-如何处理兼容问题"><span class="toc-number">1.11.9.</span> <span class="toc-text">9、****有了springmvc的IOC容器,还需要spring的IOC容器吗?为什么?如何处理兼容问题?****</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10、-Spring-MVC-怎么做异常处理？"><span class="toc-number">1.11.10.</span> <span class="toc-text">10、****Spring MVC 怎么做异常处理？****</span></a></li></ol></li></ol></li></ol>
        </div>
    
</div>


    </div>
</div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/assets/z16.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7}});</script></body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>




</html>
